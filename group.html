<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Party & Guild Data Tool</title>
    <base target="_blank">

<!--

This code is licensed under the same terms as Habitica:
    https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE

https://github.com/Alys/tools-for-habitrpg/blob/master/habitrpg_user_data_display.html

https://oldgods.net/habitica/cTheDragons/group.html

Contributors:
    cTheDragons https://github.com/cTheDragons
	based on code from
	Alys (Alice Harris), lady_alys@oldgods.net https://github.com/Alys
    thepeopleseason (James Hsiao) https://github.com/thepeopleseason
    goldfndr (Richard Finegold) https://github.com/goldfndr
    Blade Barringer https://github.com/crookedneighbor
    donoftime https://github.com/donoftime
    me_and (Adam Dinwoodie) https://github.com/me-and
	

-->


    <meta name="description" content="Party & Guild Data Tool" />
    <meta name="author" content="cTheDragons" />

	
	

	<script src="https://code.jquery.com/jquery-1.12.3.js"></script> <!--- jquery -->
	<script src="https://momentjs.com/downloads/moment-with-locales.min.js"></script> <!--- time functions -->
	<script src="js/habitica-markdown.min.js"></script> <!--- Markdown -->
	<script src="js/habitica-avatar.js"></script>  <!--- Avatar Generation https://github.com/crookedneighbor/habitica-avatar -->
	<script src="js/lodash.js"></script> <!--lodash / copy objects -->
	

	 <!--- https://datatables.net/download/ -->
	<script type="text/javascript" src="https://cdn.datatables.net/v/dt/jszip-2.5.0/pdfmake-0.1.18/dt-1.10.12/b-1.2.2/b-colvis-1.2.2/b-flash-1.2.2/b-html5-1.2.2/b-print-1.2.2/se-1.2.0/datatables.min.js"></script>
	<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/jszip-2.5.0/pdfmake-0.1.18/dt-1.10.12/b-1.2.2/b-colvis-1.2.2/b-flash-1.2.2/b-html5-1.2.2/b-print-1.2.2/se-1.2.0/datatables.min.css"/>
 	
<script type="text/javascript">
$(function() { // wraps around all our code to not pollute global namespace

//////////////////////////////////////////////////////////////////////
////   Global Variables                              /////////////////
//////////////////////////////////////////////////////////////////////

var content;  // holds site-wide content (gear names and stats, quests, etc)
var user;     // holds user's data
var group;	  // holds all groups
var party; 	  // holds party data
var challengeGroup;// holds party data
var groupForUser; //holds list of groups for the user.
var memberListToFetch = []; //holds memberList that is fetchng (30 limit)
var memberListToFetch_idOnly = []; //holds memberList that is fetchng (30 limit)

var members;  // hold members of groups
var quests; //holds quest information
var transformItems;  //hold information about transformation items
var completedStats = {by: '', pending: 0, outstanding: 0, percentage: 0, time: '', overdue: ''};
var cardItems;  //hold information about card items
var lastListMemberId = '';  // hold last member id to be used with groups
var userIsAdmin; 
var noQuestsInChat = 0;
var captureTableData = {};

//////////////////////////////////////////////////////////////////////
////   Global Constants                              /////////////////
//////////////////////////////////////////////////////////////////////
var DOUBLEQUOTES = 		'"' //This is to make my life easier... 
var SECTIONREFRESH = 	"SectionRefresh"



//////////////////////////////////////////////////////////////////////
////   Sections                              /////////////////
//////////////////////////////////////////////////////////////////////

		// TO ADD NEW SECTION: To create a Table of Content entry and Main,
		// add the unique identifier for the new section to array section to Display. 
		// If it is a section that displays table content update sectionTables too. 
		// If new content is required see formatAllDataAndCollate() 
		
		//If custom sections required add to below the Sections data... (Not there yet)


//index array for looping
var dashboardToDisplay = [
	{id: 'memberCount', label: 'Total', hoverText: 'Total Members in the Group', value: 'group.memberCount', status: 'neutral', showOnly: []},
	{id: 'memberFetch', label: 'Fetched', hoverText: 'Total Members Fetch in the Data Sample', value: 'group.memberTotals.fetchCount', status: 'neutral', showOnly: []},
	{id: 'memberQuest', label: 'Questing', hoverText: 'Number of members who have elected to quest', value: 'group.quest.memberCount', status: 'neutral', showOnly: ['party']},
	{id: 'memberInInn', label: 'In Inn', hoverText: 'Total Members In the Inn', value: 'group.memberTotals.inInn', status: 'danger', showOnly: []},
	{id: 'memberActiveLess12Hr', label: 'Active < 12 hr', hoverText: 'Total Members Active in 12 Hours or Less', value: 'group.memberTotals.activeLess12Hr', status: 'safe', showOnly: []},
	{id: 'memberActiveLess24Hr', label: 'Active 12 hr < 24 hr', hoverText: 'Total Members Active between 12 and 24 Hours', value: 'group.memberTotals.activeLess24Hr - group.memberTotals.activeLess12Hr', status: 'safe', showOnly: []},
	{id: 'memberActiveLessWeek', label: 'Active 24 hr < 1 wk', hoverText: 'Total Members Active between 24 Hours and 1 week', value: 'group.memberTotals.activeLessWeek - group.memberTotals.activeLess24Hr', status: 'neutral', showOnly: []},
	{id: 'memberActiveLessMonth', label: 'Active 1 wk < 1 mth', hoverText: 'Total Members Active between 1 week and 1 month', value: 'group.memberTotals.activeLessMonth - group.memberTotals.activeLessWeek', status: 'neutral', showOnly: []},
	{id: 'memberActiveOverMonth', label: 'Active > 1 month', hoverText: 'Total Members Active over 1 month', value: 'group.memberTotals.fetchCount - group.memberTotals.activeLessMonth', status: 'danger', showOnly: []}
]


var sectionsToDisplay = [	
	{type: 'heading', id: 'headingGroup', title: 'Party & Guild Details', showOnly: [], description: ''},
		{type: 'sectionCustom', id: 'overview', title: 'Overview', showOnly: [], description: 'Overview of Party & Guild with Guild stats.', functionCreate: 'formatOverviewSection'},
		{type: 'sectionTable', id: 'transformMembers', title: 'Transformation Items & Cards', showOnly: ['party'], description: 'Give cards to or transform all your party members with your transformational items!'},
		{type: 'sectionTable', id: 'challengeGroup', title: 'Challenge List', showOnly: [], description: 'Lists all challenges for the Guild/Party.'},
	{type: 'heading', id: 'headingGroup2', title: 'Communication', showOnly: [], description: ''},
		{type: 'sectionTable', id: 'chatExport', title: 'Chat Export', showOnly: [], description: 'Exportable table of the chat from the Party & Guild. The easy way to see if your challengers posted new prompts. Or to track team work.'},
		{type: 'sectionTable', id: 'chatNotSystemExport', title: 'Chat Export without System Msg', showOnly: ['party'], description: 'Will only show if party is selected. Exportable table of the chat from the Party & Guild without system messages.'},
		{type: 'sectionTable', id: 'chatSystemExport', title: 'Chat Export only System Msg', showOnly: ['party'], description: 'Will only show if party is selected. Exportable table of the chat from the Party & Guild of only the system messages.'},
		{type: 'sectionTable', id: 'chatLikes', title: 'Chat Likes', showOnly: [], description: 'Shows who has liked which chat message.'},
		{type: 'sectionTable', id: 'displayInboxSection', title: 'PMs', showOnly: [], description: 'Displays personal messages you have exchanged with guild members you have fetched.'},		
	{type: 'heading', id: 'headingMember', title: 'Member Information', showOnly: [], description: ''},
		{type: 'sectionTable', id: 'memberList', title: 'Member List', showOnly: [], description: 'A table listing profile information of each member of the group.'},
		{type: 'sectionTable', id: 'memberActivity', title: 'Member Activity', showOnly: [], description: 'A table listing how active each member of the group is (date-hour format).'},
		{type: 'sectionTable', id: 'memberRelativeActivity', title: 'Member Activity (Relative)', showOnly: [], description: 'A table listing how long it has been since each one of the members has been active.'},
	{type: 'heading', id: 'headingMember2', title: '', showOnly: [], description: ''},	
		{type: 'sectionTable', id: 'memberStats', title: 'Member Stats', showOnly: [], description: 'A table listing health, mana, XP and other stats of each member.'},
		{type: 'sectionTable', id: 'memberAttributes', title: 'Member Attributes', showOnly: [], description: 'A table listing strength, intelligence, perception and constitution of the members.'},
		{type: 'sectionTable', id: 'memberBuff', title: 'Member Buffs & Transformation', showOnly: ['party'], description: 'A table listing the number of buff and transformations completed by members.'},
	{type: 'heading', id: 'headingQuest', title: 'Quests', showOnly: ['party'], description: ''},
		{type: 'sectionTable', id: 'memberQuest', title: 'Quests Participation', showOnly: ['party'], description: 'Only available for a party (and not a guild). A table showing if any members are in a quest. Also allows to join or leave and if the quest owner/party leader force start or abort the quest.'},
		{type: 'sectionTable', id: 'memberDamage', title: 'Member Quest Progress', showOnly: ['party'], description: 'A table listing the quest progress pending and completed by members.  Shows pending damage by the party for the current quest.'},
		{type: 'sectionTable', id: 'questCompleted', title: 'All Quests Completed', showOnly: ['party'], description: 'A table showing which quests have and have not been completed by the party and which scrolls owned by the party.'},
		{type: 'sectionTable', id: 'questPetCompleted', title: 'Pet Quests Completed', showOnly: ['party'], description: 'Focus on the Pet Quests and shows which ones have been completed by the party, or left unfinished. Shows the pet scrolls owned by all party members.'},
		{type: 'sectionTable', id: 'questMagicCompleted', title: 'Magic Quests Completed', showOnly: ['party'], description: 'Focus on the Magic Hatching Quests and shows which ones have been completed by the party, or left unfinished. Shows the pet scrolls owned by all party members.'}
]

//named for searching
//Not sure this is bad as mixing constants with definitions... but hey :)
var sectionTables =	{}
sectionTables['transformMembers'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level',  'Tier', 'Contributor', 'Last Active', 'Last Cron', 'Last Drop', 'Last Chat', 'Last Chat Text', 'Next Birthday', 'Transform Status', 'Last Cast Transform'  ], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl', 'contribPretty.level', 'contribPretty.text', 'lastActive.shortDate',  'lastLoggedIn.shortDate', 'lastDropItem.shortDate', 'lastChat.occured.shortDate', 'lastChat.textPretty', 'creation.nextBirthday.shortDate', 'transformStatus', 'lastTransformation.occured.shortDate'],
	babyBear: {show: [1,4,12,13], orderBy: [[1, 'asc']]},
	mamaBear: {show: [1,2,3,4,7,8,12,13], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [4,5]}],
	subTitle: function (){
		if (debug) console.log('debug Start subTitle Transform')
		if (debugShowObject) console.log(transformItems)
		//list transformational items for user
		var html = ''
		html += '<h3><table><tr>'
		$.each(transformItems, function(index, obj) {
			html += '<td>' + obj.imgTag + '</td><td>' + obj.name + '</td><td>' + obj.userAmount + '</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td>'
		});
		html += '<td>' + '<img src="' + imageURL + 'shop_gold.png' + '" alt="' + 'Gold Coin' + '"> </td><td>' + 'Gold' + '</td><td>' + Math.floor(user.stats.gp) + '</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td>'
		html += '</tr></table></h3>'
		html += 'To select records in bulk select the first and then hold down the shift key to select the last record. To select multiples hold down the ctrl key while selecting.'
		if (debugShowObject) console.log(html)
		return html 
		
	},
	leadershipButton: false,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1,
	extraButton: function(){
		var cardButton = []
		var tranformButton = []
		var returnButton = []
		var singleButton = {}
		
		$.each(cardItems, function(index, obj) {
			singleButton = {
				text: obj.name + ' (' + obj.cost + ' GP)', 
				action: function ( e, dt, node, config ) {
					var rowData = sectionTables['transformMembers'].table.rows( { selected: true } ).data().toArray();
					var uuidIndex = sectionTables['transformMembers'].uuidIndex;
					var nameIndex = sectionTables['transformMembers'].nameIndex;
					postGiveCard(obj.id, rowData, uuidIndex, nameIndex)	
				}
			}	
			cardButton.push(singleButton)
		});
		
		$.each(transformItems, function(index, obj) {
			if (obj.userAmount > 0) {
				singleButton = {
					text: obj.name, 
					action: function ( e, dt, node, config ) {
						var rowData = sectionTables['transformMembers'].table.rows( { selected: true } ).data().toArray();
						var uuidIndex = sectionTables['transformMembers'].uuidIndex;
						var nameIndex = sectionTables['transformMembers'].nameIndex;
						postTransformMember(obj.id, rowData, uuidIndex, nameIndex)	
					}
				}	
				tranformButton.push(singleButton)
			}
		});
		
		returnButton = []
		if (cardButton.length > 0) {
			returnButton.push({
				extend: 'collection',
				text: 'Cards',
				buttons: cardButton,
				autoClose: true,
				className: 'cardButton'
			})
		}
				
		if (tranformButton.length > 0) {
			returnButton.push({
				extend: 'collection',
				text: 'Transform',
				buttons: tranformButton,
				autoClose: true,
				className: 'tranformButton'
			})
		}	
			
		return returnButton
	}
}

sectionTables['challengeGroup'] = {
	type: 'challengeGroup',
	dataSet: [], 
	dataSetHeader: ['Challenge Id', 'Title', 'Description', 'Gems', 'Created', 'Last Updated', 'Owner Id', 'Owner', 'Owner Display Name', 'Owner Last Active', 'Participants', 'Offical'], 
	dataTable: ['id', 'nameLink', 'descriptionPretty', 'prize', 'creation.shortDate', 'lastUpdated.shortDate', 'leader.id', 'leader.profile.usernameNotPretty', 'leader.profile.nameNotPretty', 'leader.lastActive.shortDate', 'memberCount', 'officalPretty'],
	babyBear: {show: [1,3,4,7,10], orderBy: [[4, 'desc']]},
	mamaBear: {show: [1,2,3,4,7,8,9,10], orderBy: [[4, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[4, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [11]}, {'className': 'dt-right', 'targets': [3,10]}],
	subTitle: function (){
		var html = ''
	
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},	
	leadershipButton: false,
	chatButton: false,
	uuidIndex: 6,
	nameIndex: 7
}

sectionTables['chatExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
	
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},	
	leadershipButton: true,
	chatButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['chatNotSystemExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},	
	leadershipButton: true,
	chatButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['chatSystemExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		return html 
	},	
	leadershipButton: false,
	chatButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['chatLikes'] = {
	type: 'chatLikes',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'Like Id', 'Like UserName', 'Like Display Name', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Text'], 
	dataTable: ['chat.id', 'id', 'usernameNotPretty', 'nameNotPretty', 'chat.uuid', 'chat.usernameNotPretty', 'chat.userNotPretty', 'chat.contribPretty.level', 'chat.contribPretty.text', 'chat.contribPretty.contributions', 'chat.contribPretty.admin', 'chat.creation.shortDate', 'chat.timestamp', 'chat.textPretty'],
	babyBear: {show: [2,5,11,13], orderBy: [[11, 'desc']]},
	mamaBear: {show: [1,2,3,4,5,6,11,13], orderBy: [[11, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[11, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [10]}, {'className': 'dt-right', 'targets': [7,12]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	chatButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['displayInboxSection'] = {
	type: 'inbox',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Sent', 'Text', 'Appearance', 'Message Id'],
	dataTable: ['uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'sentPretty', 'textPretty', 'userStylesPretty', 'id'],
	babyBear: {show: [1,7,9,10], orderBy: [[7, 'desc']]},
	mamaBear: {show: [1,2,3,7,9,10], orderBy: [[7, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[7, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [6,9]}, {'className': 'dt-right', 'targets': [3,8]}],
	subTitle: function (){
		var html = ''
		html += 'PMs are filted based on fetched members only. That is those that are listed in <span class="showHideToggle" data-target="memberListSection" data-closemainsections="true">Member List</span>.'
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	chatButton: false,
	pmidIndex: 12,
	uuidIndex: 0,
	nameIndex: 1
}

sectionTables['memberList'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Profile', 'Class', 'Level', 'Tier', 'Contributor', 'Contributions',  'Admin',  'Born', 'Next Birthday', 'Can PM?', 'Avatar'],
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'blurbPretty', 'stats.classPretty', 'stats.lvl', 'contribPretty.level', 'contribPretty.text',  'contribPretty.contributions', 'contribPretty.admin',  'creation.shortDate',  'creation.nextBirthday.shortDate', 'inbox.canPM','profile.avatar'],
	babyBear: {show: [1,4,5,13], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,5,6,7,11,13], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [ 9, 12 ]}, {'className': 'dt-right', 'targets': [ 5, 6 ]}],
	subTitle: function (){
		var html = ''
		html += sectionHeadingLeadership()
		return html 
	},	
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}

sectionTables['memberActivity'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Tier', 'Contributor', 'Born', 'Last Active', 'Last Cron', 'Last Drop', 'Last Chat', 'Total Chat Lines', 'Last Chat Text', 'In Inn'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl',  'contribPretty.level', 'contribPretty.text', 'creation.shortDate', 'lastActive.shortDate', 'lastLoggedIn.shortDate', 'lastDropItem.shortDate', 'lastChat.occured.shortDate', 'lastChat.countTotal', 'lastChat.textPretty', 'preferences.sleep'],
	babyBear: {show: [1,8,14], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,8,9,10,11,12,14], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [ 14 ]}, {'className': 'dt-right', 'targets': [4,5,12]}],
	subTitle: function (){
		var html = sectionHeadingLastActive()
	html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}

sectionTables['memberRelativeActivity'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Tier', 'Contributor', 'Born', 'Last Active', 'Last Cron', 'Last Drop', 'Last Chat', 'Total Chat Lines', 'Last Chat Text', 'In Inn'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl',  'contribPretty.level', 'contribPretty.text', 'creation.relativeTime', 'lastActive.relativeTime', 'lastLoggedIn.relativeTime', 'lastDropItem.relativeTime', 'lastChat.occured.relativeTime', 'lastChat.countTotal', 'lastChat.textPretty', 'preferences.sleep'],
	babyBear: {show: [1,8,14], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,8,9,10,11,12,14], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [
		{'className': 'dt-center', 'targets': [ 14 ]}, {'className': 'dt-right', 'targets': [4,5,12]},
		{'orderable': false, 'targets': [7,8,9,10,11]}
	],
	subTitle: function (){
		var html = sectionHeadingLastActive()
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}

sectionTables['memberStats'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Tier', 'Born', 'Last Active', 'Last Cron', 'Health', 'Current Mana', 'Mana Max', 'Current Mana %', 'Gold', 'XP', 'XP to Next Level' ], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl',  'contribPretty.level', 'creation.shortDate', 'lastActive.shortDate', 'lastLoggedIn.shortDate', 'stats.hpPretty', 'stats.mpPretty', 'stats.maxMPPretty', 'stats.percentageMP', 'stats.gpPretty', 'stats.expPretty', 'stats.toNextLevelPretty'],
	babyBear: {show: [1,9,10,11], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,7,8,9,10,11,12], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [4,5,9,10,11,12,13,14,15]}],
	subTitle: function (){
		var html = ''
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}


sectionTables['memberAttributes'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Last Cron', 'STR lvl', 'STR alloc', 'STR buff', 'STR gear', 'STR gear+', 'STR total', 'INT lvl', 'INT alloc', 'INT buff', 'INT gear', 'INT gear+', 'INT total',  'CON lvl', 'CON alloc', 'CON buff', 'CON gear', 'CON gear+', 'CON total', 'PER lvl', 'PER alloc', 'PER buff', 'PER gear', 'PER gear+', 'PER total'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl', 'lastLoggedIn.shortDate', 'attributeTotals.str.lvl', 'attributeTotals.str.allocated', 'attributeTotals.str.buff', 'attributeTotals.str.gear', 'attributeTotals.str.gearBuff', 'attributeTotals.str.total', 'attributeTotals.int.lvl', 'attributeTotals.int.allocated', 'attributeTotals.int.buff', 'attributeTotals.int.gear', 'attributeTotals.int.gearBuff', 'attributeTotals.int.total', 'attributeTotals.con.lvl', 'attributeTotals.con.allocated', 'attributeTotals.con.buff', 'attributeTotals.con.gear', 'attributeTotals.con.gearBuff', 'attributeTotals.con.total', 'attributeTotals.per.lvl', 'attributeTotals.per.allocated', 'attributeTotals.per.buff', 'attributeTotals.per.gear', 'attributeTotals.per.gearBuff', 'attributeTotals.per.total'],
	babyBear: {show: [1,3,11,17,23,29], orderBy: [[1, 'asc']]},
	mamaBear: {show: [1,2,3,4,5,11,17,23,29], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}],
	subTitle: function (){
		var html = ''
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}



sectionTables['memberBuff'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Last Active', 'Last Cron', 'Last Buff', 'Total Buffs', 'Total Buff < 12 hr', 'Total Buff < 24 hr', 'Last Transform', 'Total Transform', 'Total Transform < 12 hr', 'Total Transform < 24 hr'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl', 'lastActive.shortDate', 'lastLoggedIn.shortDate', 'lastBuff.occured.shortDate', 'lastBuff.countTotal', 'lastBuff.countLess12Hr', 'lastBuff.countLess24Hr', 'lastTransformation.occured.shortDate', 'lastTransformation.countTotal', 'lastTransformation.countLess12Hr', 'lastTransformation.countLess24Hr'],
	babyBear: {show: [1,3,4,8,12], orderBy: [[1, 'asc']]},
	mamaBear: {show: [1,2,3,4,5,7,7,10,11,12,14], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [4,8,9,10,12,13,14]}],
	subTitle: function (){
		var html = ''
		html = '<p>Buff Totals are only counted for chat period showing.</br><span class="highlight">Chat period: </span>' + group.chatTotals.firstChat.dateAndTime + ' to ' + group.chatTotals.lastChat.dateAndTime + ' (' + group.chatTotals.chatDayPeriod + ' days)</p>'
		html += '<p>Buffs and Transformational castings stats are based off the players name. If the player has changed their name recently their stats may not show correctly.</p>'
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}


sectionTables['memberQuest'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Tier', 'Last Active', 'Last Cron', 'Owner', 'In Inn', 'In Quest' ], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl',  'contribPretty.level', 'lastActive.shortDate', 'lastLoggedIn.shortDate', 'quest.leader', 'preferences.sleep', 'quest.inQuest'],
	babyBear: {show: [1,7,9,10], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,6,7,9,10], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [8,9,10]}, {'className': 'dt-right', 'targets': [4,5]}],
	subTitle: function (){
		var html = ''
		if (group.quest.key == undefined) {
			html += '<p>No Quest Active!</p>'
		} else {
			var questStatus = ''
			
			if (group.quest.active) {
				questStatus='active' 
			} else {
				questStatus='pending' 
			}
			html += '<p><span class="highlight">Current Quest: </span>' + quests[group.quest.key].text + ' ( ' + questStatus + ' )</p>'
			if (group.memberCount != group.memberTotals.fetchCount) html = incompleteDataDueNotAllParty + html
		}
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1,
	extraButton: function(){
		var returnButton = []
		
		
		//always create button just hide them when not needed.
		var acceptButton = {
			text: 'Accept Quest',
			className: 'questAcceptButton',
			name: 'questAcceptButton',
			action: function ( e, dt, node, config ) {
				postQuestAccept()	
			}
		}	
		returnButton.push(acceptButton)
		
		var rejectButton = {
			text: 'Reject Quest', 
			className: 'questRejectButton',
			name: 'questRejectButton',
			action: function ( e, dt, node, config ) {
				postQuestReject()	
			}
		}	
		returnButton.push(rejectButton)
		
		var startButton = {
			text: 'Start Quest Now', 
			className: 'questStartButton',
			name: 'questStartButton',
			action: function ( e, dt, node, config ) {
				postQuestStart()	
			}
		}	
		returnButton.push(startButton)

		var abortButton = {
			text: 'Abort Quest', 
			className: 'questAbortButton',
			name: 'questAbortButton',
			action: function ( e, dt, node, config ) {
				postQuestAbort()	
			}
		}	
		returnButton.push(abortButton)
		
		var leaveButton = {
			text: 'Leave Quest', 
			className: 'questLeaveButton',
			name: 'questLeaveButton',
			action: function ( e, dt, node, config ) {
				postQuestLeave()	
			}
		}	
		returnButton.push(leaveButton)

		
		return returnButton
	},
	dynamicButtons: true
}



sectionTables['memberDamage'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Last Active', 'Last Cron', 'In Quest', 'Previous Quest Collection', 'Current Quest Collection', 'Total Collection',  'Previous Quest Damage', 'Current Quest Damage', 'Total Damage', 'Previous Boss Damage', 'Current Boss Damage', 'Total Boss Damage', 'Pending Damage', 'Req To Finish'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl', 'lastActive.shortDate', 'lastLoggedIn.shortDate', 'quest.inQuest', 'quest.collectionTotalPrevious', 'quest.collectionTotalCurrent', 'quest.collectionTotal', 'quest.damageTotalPrevious', 'quest.damageTotalCurrent', 'quest.damageTotal', 'quest.damageBossPrevious', 'quest.damageBossCurrent', 'quest.damageBoss', 'quest.pending', 'quest.reqFinish'],
	babyBear: {show: [1,3,4,6,7,9,12,15,17,18], orderBy: [[6, 'asc']]},
	mamaBear: {show: [1,2,3,4,6,7,8,9,11,12,14,15,17,18], orderBy: [[6, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[6, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,8,9,10,11,12,13,14,15,16,17,18]}],
	subTitle: function (){
		var html = '' 
		html += '<p>Quest Progress Totals are only counted for chat period showing. Quest progress stats are based off the players name. If the player has changed their name recently their stats may not show correctly.</p>'
		html += sectionHeadingChat()
		html += '<p><span class="highlight">Number Of Quests: </span>'
		if (noQuestsInChat < 0) {
			html += 'No Quest Data available. ' 
		} else if (noQuestsInChat == 0)
			if (group.quest.active) {
				html += 'Less than 1. Current quest data incomplete. '
			} else {
				html += 'Less than 1. Prior quest data incomplete. '
			}
		 else if (noQuestsInChat == 1)
			if (group.quest.active) {
				html += 'Less than 2. Current quest data complete. Prior quest data incomplete. '
			} else {
				html += 'Less than 2. Prior quest data complete. Data of the quest before prior is incomplete. '
			}
		else {
			if (group.quest.active) {
				html += 'Less than ' + (noQuestsInChat + 1) + '. Current quest and prior quest data are both complete. '
			} else {
				html += 'Less than ' + (noQuestsInChat + 1) + '. Prior Quest and data of quest before prior that are both complete. '
			}
		}
		html += '</ br>'
		if ((group.quest.active) && (noQuestsInChat >= 0)) {
			html += 'Current quest totals in table is for the current quest, ' + quests[group.quest.key].text + '.'
		} else {
			if (group.quest.key == undefined) {
				html += 'Current quest totals in table is for the quest just completed. '
			} else {
				html += 'Current quest totals in table is for quest prior to pending quest, ' + quests[group.quest.key].text + '.'
			}
		}
		
		html += '</p>'
		
		html += sectionQuestEstComplete()
		
		html += '</p>'
		html += sectionHeadingLeadership()
		if (group.memberCount != group.memberTotals.fetchCount) html = incompleteDataDueNotAllParty + html
		return html 
	},
	leadershipButton: true,
	chatButton: false,
	uuidIndex: 0,
	nameIndex: 1
}


sectionTables['questCompleted'] = {
	type: 'quest',
	dataSet: [], 
	dataSetHeader: ['Scroll', 'Name', 'Category', 'Type', 'Defeat By', 'XP', 'GP', 'Other Reward', 'Total Completed', 'Total Not Completed', 'Scrolls Owned' ], 
	dataTable: ['imgTagQuestScroll', 'text', 'category', 'typeOf', 'defeatBy', 'drop.exp', 'drop.gp', 'drop.rewardItemString', 'memberCompleted.memberCount',  'memberCompleted.missingCount', 'ownScroll'],
	babyBear: {show: [1,3,4,8,9,10], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,2,3,4,8,9,10], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [5,6,8,9,10]}],
	subTitle: function (){
		var html = ''
		html += '<p>Want to see which scrolls each party member has? Check out the <a href="' + sectionPPTLink() + '">Party Progress Tool</a></p>'
		if (group.memberCount != group.memberTotals.fetchCount) html = incompleteDataDueNotAllParty + html
		return html 
	},
	leadershipButton: false,
	chatButton: false
}

sectionTables['questPetCompleted'] = {
	type: 'quest',
	dataSet: [], 
	dataSetHeader: ['Scroll', 'Name', 'Pet', 'Type', 'Defeat By', 'XP', 'GP', 'Other Reward', 'Total Completed', 'Not At All', '1 Times', '2 Times', '3 Times', '4 Times', '5 Times', '6 Times', '7 Or More', 'Scrolls Owned'], 
	dataTable: ['imgTagQuestScroll', 'text', 'pet.text', 'typeOf', 'defeatBy', 'drop.exp', 'drop.gp', 'drop.rewardItemString', 'memberCompleted.memberCount', 'memberCompleted.missingCount',  'memberCompleted.only1',  'memberCompleted.only2',  'memberCompleted.only3',  'memberCompleted.only4',  'memberCompleted.only5',  'memberCompleted.only6',  'memberCompleted.only7OrMore', 'ownScroll'],
	babyBear: {show: [2,3,4,7,9,16,17], orderBy: [[9, 'desc'],[16, 'asc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	mamaBear: {show: [0,2,3,4,5,6,7,9,16,17], orderBy: [[9, 'desc'],[16, 'asc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[9, 'desc'],[16, 'asc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [5,6,8,9,10,11,12,13,14,15,16,17]}],
	subTitle: function (){
		var html = ''
		html += '<p>All quests are required to be completed 7 times each to have the maximum mounts and pets for each (3 eggs reward). However the Egg Hunt quest is only required to be completed twice as it rewards 10 eggs. The Dinosaur Unearthed and King of the Dinosaurs Quest need to be completed 7 times in total as both reward Tyrannosaurs.</p>'
		html += '<p>Want to see which quest pets and pet scrolls each party member has? Check out the <a href="' + sectionPPTLink() + '">Party Progress Tool</a></p>'
		if (group.memberCount != group.memberTotals.fetchCount) html = incompleteDataDueNotAllParty + html
		return html 
	},
	leadershipButton: false,
	chatButton: false
}

sectionTables['questMagicCompleted'] = {
	type: 'quest',
	dataSet: [], 
	dataSetHeader: ['Scroll', 'Name', 'Potion', 'Type', 'Defeat By', 'XP', 'GP', 'Other Reward', 'Total Completed', 'Not At All', '1 Times', '2 Times', '3 Times', '4 Times', '5 Times', '6 Times Or More', 'Scrolls Owned'], 
	dataTable: ['imgTagQuestScroll', 'text', 'magicPotion.text', 'typeOf', 'defeatBy', 'drop.exp', 'drop.gp', 'drop.rewardItemString', 'memberCompleted.memberCount', 'memberCompleted.missingCount',  'memberCompleted.only1',  'memberCompleted.only2',  'memberCompleted.only3',  'memberCompleted.only4',  'memberCompleted.only5',  'memberCompleted.only6OrMore', 'ownScroll'],
	babyBear: {show: [2,3,4,7,9,15,16], orderBy: [[9, 'desc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	mamaBear: {show: [0,2,3,4,5,6,7,9,15,16], orderBy: [[9, 'desc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[9, 'desc'],[15, 'asc'],[14, 'asc'],[13, 'asc'],[12, 'asc'],[11, 'asc'],[10, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [5,6,8,9,10,11,12,13,14,15,16]}],
	subTitle: function (){
		var html = ''
		html += '<p>All quests are required to be completed 6 times each to have the maximum mounts and pets for each type. (3 potions reward).</p>'
		if (group.memberCount != group.memberTotals.fetchCount) html = incompleteDataDueNotAllParty + html
		return html 
	},
	leadershipButton: false,
	chatButton: false
}

function sectionHeadingLastActive() {	
	var html = ''
	html += '<p>The Last Active Date is the last date of either the Last Cron, Last Chat for this '
	if (groupId == 'party') {
		html += 'party, <span class="showHideToggle" data-target="memberBuffSection" data-closemainsections="true">Last Buff, Last Transformation,</span> '
	} else
	{
		html += 'guild, '
	}
	html += 'or Last Drop. A member may be active in other areas of Habitica, for example be chatting in another guild but that will not show here.</p>'
	return html
}

function sectionHeadingChat() {
		var html = ''
		if (group.chat.length > 0) {
			html += '<p><span class="highlight">Chat period: </span>' + group.chatTotals.firstChat.dateAndTime + ' to ' + group.chatTotals.lastChat.dateAndTime + ' (' + group.chatTotals.chatDayPeriod + ' days)</p>'
		} else {
			html +=  '<p>It appears a vow of silence has been taken, as there is no chat to report on.</p>'
		}
		return html
}

function sectionHeadingLeadership() {
		var html = ''
		if ((userId == group.leader.id) || (userIsAdmin)) {
			var userGemAmount = user.balance * 4 
			html += '<p>To select records in bulk select the first and then hold down the shift key to select the last record. To select multiples hold down the ctrl key while selecting.</p>'
		}
		return html
}

				
function sectionPPTLink(){
	link = ''

	link += serverPPT
	
	$.each(memberListToFetch, function(index, obj){	
		link += obj.id + hookPPT
	})
	
	//remove the extra hook
	link = link.slice(0, -1)
	
	return link
}		

function sectionQuestEstComplete() {
	html = ''
	
	if (group.quest.key != undefined) {
		html += '<p><span class="highlight">Est of Completion: </span>' 
		
		if (completedStats.by == '') {
			html += 'Not enough work yet to complete the quest in next 24 hours. (Keep battling those tasks!) '
		} else {
			if (moment().isBefore(completedStats.time.utcTime)) {
				html += completedStats.time.relativeTime + ' by ' 
			} else {
				html += 'Any moment now with ' 
			}
			
			html += completedStats.by + '. '
		}		

		html += 'Currently <span class="highlight">' 
		
		if (quests[group.quest.key].boss) {	
			html += completedStats.pending + '</span> HP party pending damage to kill the boss with <span class="highlight">' + completedStats.outstanding + '</span> HP remaining '	
		} else {
			if (completedStats.by != '') {
				html += completedStats.pending + '</span> items collected by the party with a <span class="highlight">' + completedStats.percentage + '%</span> even distribution chance of finding all ' 
			} else {
				html += completedStats.pending + '</span> items collected by the party, ' 
			}
			html += completedStats.outstanding + '</span> outstanding items to be collected '
		}
		
		html += 'in the quest' // ' + quests[group.quest.key].text
		
		
		if (group.quest.active) {
			html += '. A'
		} else {
			html += '(Pending). Assuming quest will start before next cron and a'
		}
		html += 'ssuming everyone crons remain the same as yesterday. '
		
		if (completedStats.overdue.length > 0) html += 'The following users were ignored as they were either in the inn or have not checked in more than 24 hours: ' + completedStats.overdue + '. '
	}
	return html
}


//export options	
var exportOptions = [
	{id: 'babyBear', shortDesc: 'Baby Bear', longDesc: 'Displays & exports short table format'},
	{id: 'mamaBear', shortDesc: 'Mama Bear', longDesc: 'Displays & exports medium table format'},
	{id: 'papaBear', shortDesc: 'Papa Bear', longDesc: 'Displays & exports max table format'}
];
var exportFormats = [
	{id: 0, shortDesc: 'Warm Porridge', longDesc: 'Displays & exports with Emoji & Text converted but HTML removed', convertMarkup: true, removeHtml: true, convertLineBreaks: false},
	{id: 1, shortDesc: 'Hot Porridge', longDesc: 'Displays & exports in exact Habitica HTML format', convertMarkup: true, removeHtml: false, convertLineBreaks: false},
	{id: 2, shortDesc: 'Cold Porridge', longDesc: 'Displays & exports in raw format', convertMarkup: false, removeHtml: false, convertLineBreaks: true}
];


				 
					
//////////////////////////////////////////////////////////////////////
////   Global Connection Variables      //////////////////////////////
//////////////////////////////////////////////////////////////////////
var warningMessage				= 	'PLEASE ENSURE YOUR MESSAGE IS:\n' +
									'\n\u2022 is respectful, supportive and courteous;' + 
									'\n\u2022 is not spam, including unwanted advertisements of products, social media accounts, etc;' +
									'\n\u2022 is not begging for a gift of gems or a subscription' +
									'\n\u2022 meets all requirements of the Community Guidelines of Habitica (https://habitica.com/static/community-guidelines). ' +
									'\n\u2022 meets all requirements of the Term of Service of Habitica (https://habitica.com/static/terms). ' +
									'\n' +
									'\nFailure to do so can lead to minor consequences (like warnings) to severe consequences including account bans & deletions.' +
									'\n' +
									'\nIf you have any concerns, please email Admin (admin@habitica.com) for clarification.'
var infoMessage					= 'To add a new line type {nl}.' + 
									'\nFor a paragraph break {nl}{nl}.'

var serverName					= 'Habitica'; // used in "loading" message
var serverUrl					= 'https://habitica.com/api/v3';
var serverPathContent			= '/content?language=en';
var serverPathUser				= '/user';
var serverPathGroup				= '/groups'
var serverPathChallengeGroup	= '/challenges/groups'
var serverPathParty				= '/groups/party'
var serverPathGroupMemberPart	= '/members' //will be /groups/:groupId/members
var serverPathMemberProfilePart	= '/members' //will be /members/:uid
var serverPathRemoveUser		= '/removeMember' //will be /groups/:groupId/removeMember/:uid
var serverPathMessageUser		= '/members/send-private-message'
var serverPathCastSkill			= '/user/class/cast' //will be /cast/:uid
var serverPathBuySpecialSkill	= '/user/buy-special-spell' //will be /buy-special-spell/:key
var serverPathQuestAccept		= '/groups/party/quests/accept' //api/v3/groups/:groupId/quests/accept
var serverPathQuestReject		= '/groups/party/quests/reject' //api/v3/groups/:groupId/quests/reject
var serverPathQuestStart		= '/groups/party/quests/force-start' //api/v3/groups/:groupId/quests/force-start
var serverPathQuestLeave		= '/groups/party/quests/leave' //api/v3/groups/:groupId/quests/force-start
var serverPathQuestAbort		= '/groups/party/quests/abort' //api/v3/groups/:groupId/quests/force-start
var serverPathPostChatPart		= '/chat' //api/v3/groups/:groupId/chat
var imageURL					= 'https://habitica-assets.s3.amazonaws.com/mobileApp/images/' 
var imageShopPrefix             =  'shop_'
var imageQuestPrefix            =  'quest_'
var imageQuestPrefix            =  'quest_'
var imageQuestScrollPrefix      =  'inventory_quest_scroll_'
var imageFileSuffix				= '.png'
var imageGem					= 'Pet_Currency_Gem1x.png'
var serverHabiticaGuild			= 'https://habitica.com/groups/guild/'
var serverHabiticaProfile		= 'https://habitica.com/profile/'
var serverCDT					= 'https://oldgods.net/habitica/cTheDragons/challenge.html'
var hookCDT_uid					= 'uuid'
var hookCDT_challengeid			= 'challengeId'
var serverPPT					= 'https://habiticapartytools.surge.sh/?users='
var hookPPT						= '|'

var userId						= '';
var apiToken					= '';
var clientId					= 'bc10ec41-4213-4482-bbb8-558e3c3ea8d5-PartyGuildDataTool'
var groupId 					= ''; //holds selected group (drop down)
var hideAvatar					= false;
var clearNotification			= false;
var exportOption 			 	= 'babyBear';
var exportFormat			 	= 1;
var groupDropDownShow			= false;
var maxMembersToFetch 			; //hold the max members to fetch input (will be rounded up to nearest 30 due to function)
var maxMembersToFetch 			; //hold the max members to fetch input (will be rounded up to nearest 30 due to function)
var ajaxTryAgainMax				= 3;
var debug						= false;
var debugShowObject				= false;

if (debug || debugShowObject) serverName = '*** TURN DEBUG OFF! *** - ' + serverName
if (debug) console.log('debug 1');

var sectionOpen = ''; // holds the ID attribute of a section of the page;
                      // persists through re-fetch of data so we can
                      // reopen that section when the new data arrives
var tellMe = '<a href="https://github.com/cTheDragons">tell me</a>';

var neverDate = '1900-01-01'
var notAvailableMember = '-Member Not In Listed-'
var noUsernamePrefix = '-Unknown Username- Display Name: '
var incompleteDataDueNotAllParty = '<p><span class="lowlight">Not all party members fetched. Data may not show correctly.</span></p>'
//////////////////////////////////////////////////////////////////////
////   allow Show/Hide Toggling to work    ///////////////////////////
//////////////////////////////////////////////////////////////////////
enableShowHideToggling(); // needed here to enable Version Changes link
var openRelatedSections = function(){} // redefined later when user data exists
function enableShowHideToggling() {
if (debug) console.log('debug enableShowHideToggling');

	//Populate Selector
	var htmlGroupId = getGroupSelectorHtml()
	var htmlExport =  getExportOptionsHtml()
	var htmlDesc =  getExportDescHtml()
	var htmlSection = getSectionDescHtml()
	
	$('#groupSelector').html(htmlGroupId)
	$('#exportOptionSelector').html(htmlExport)
	$('#exportOptionDesc').html(htmlDesc)
	$('#sectionDesc').html(htmlSection)

    // $('.showHideToggle').click(function(event)
	$('body').unbind('click')
    $('body').on('click', '.showHideToggle', function(event){
        var target = $(this).data("target");
        var wantToShow = (! $('#' + target).is(':visible')
                       || $(this).data("forceopen"));
            // wantToShow is false if the target is already open
            // (i.e., the user wants to close it)
            // unless the toggle's attributes force it to always be
            // opened (e.g., a link from the dashboard)
        var linktext = $(this).data("linktext") || false;
        if ($(this).data("closemainsections")) {
            $('#MAIN > *').hide();
        }
        if (wantToShow) {
            sectionOpen = target;
            $('#' + target).show();
            if (linktext) {
                $(this).text('hide ' + linktext);
            }
            openRelatedSections();
        }
        else {
            $('#' + target).hide();
            if (linktext) {
                $(this).text('show ' + linktext);
            }
            if ($(this).data("scrolltotop")) {
                window.scrollTo(0, 0);
            }
        }
        var toggleTarget = $(this).data("resettoggletext") || false;
        if (toggleTarget) {
            $('#' + toggleTarget).text('show '
                        + $('#' + toggleTarget).data("linktext"));
        }
    });
    $('body').on('click', '.mainSectionClose', function(event){
        $('#MAIN > *').hide();
        window.scrollTo(0, 0);
    });
	
	function getGroupSelectorHtml() {
		var html = '';
		
		if (groupDropDownShow == false) {
			html += '<input class="div-getGroup" type="button" value="Get My Guilds" /><label><span class="formNote"> OR Enter the URL</span></label>'
			html += '<label for="groupId"><span>Guild ID/Party</span>'
			html += '<input type="text" name="groupId" id="groupId" value="party" />'
			html += ' </label>'
		} else {
			html += '<input class="div-switchToManual" type="button" value="Switch to Manual Input" /><label for="groupId"><span> OR Select </span></label>'
			
			html += '<label for="groupId"><span>Guild ID/Party</span>'
			html += '<select class="groupId" id="groupId" name="groupId">'
			$.each(groupForUser, function(index, obj){	
				html += '<option value="' + obj.id + '"'
				html += '>' + obj.name + '</option>';		
			});	
			html += '</select>'
			html += '</label>'
		}
		
		return html
	}
	
	function getExportOptionsHtml()
	{
		var html = '';
		
		html +=  '<label for="exportOption"><span>Column Option</span>'
		html +=  '<select name="exportOption" id="exportOption">';
		if (debugShowObject) console.log(exportOptions);
		$.each(exportOptions, function(index, obj){
			html += '<option value="' + obj.id + '"'
			if (obj.id == exportOption) html += ' selected '
			html += '>' + obj.shortDesc + '</option>';
		});
		html += '</select></label>'

		html +=  '<label for="exportFormat"><span>Text Format</span>'
		html +=  '<select name="exportFormat" id="exportFormat">';
		if (debugShowObject) console.log(exportOptions);
		$.each(exportFormats, function(index, obj){
			html += '<option value="' + obj.id + '"'
			if (obj.id == exportFormat) html += ' selected '
			html += '>' + obj.shortDesc + '</option>';
		});
		html += '</select></label>'

		
		return html
	}
	
	function getExportDescHtml()
	{
		var html = '';
		
		html +=  '<p class="highlight">Column Options Description:</p>'
		html +=  '<ul>';
		$.each(exportOptions, function(index, obj){
			html += '<li><span class="lowlight">' + obj.shortDesc + '</span>: ' + obj.longDesc + '</li>';
		});
		html += '</ul>'

		html +=  '<p class="highlight">Text Format Description:</p>'
		html +=  '<ul>';
		$.each(exportFormats, function(index, obj){
			html += '<li><span class="lowlight">' + obj.shortDesc + '</span>: ' + obj.longDesc + '</li>';
		});
		html += '</ul>'
		
		return html
	}
	
	function getSectionDescHtml()
	{
		var html = '';
		
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type != 'heading') html += '<li><span class="subheading">' + obj.title + '</span>: ' + obj.description + '</li>';
		});
		
		return html
	}
}


//////////////////////////////////////////////////////////////////////
////   Get UUID from URL      ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
var url_vars = getUrlVars();
if (url_vars.hasOwnProperty("userId")) {
	$("#userId").val(url_vars.userId);
} else if (url_vars.hasOwnProperty("userid")) {
	$("#userId").val(url_vars.uuid);
} else if (url_vars.hasOwnProperty("uuid")) {
	$("#userId").val(url_vars.uuid);
}
if (url_vars.hasOwnProperty("groupId")) {
	$("#groupId").val(url_vars.groupId);
} else if (url_vars.hasOwnProperty("groupid")) {
	$("#groupId").val(url_vars.groupId);
}
if (url_vars.hasOwnProperty("max")) {
	$("#maxMembersToFetch").val(url_vars.max);
}
if (url_vars.hasOwnProperty("hide_avatar")) {
	if ((url_vars.hide_avatar == "checked") || (url_vars.hide_avatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hide_avatars")) {
	if ((url_vars.hide_avatars == "checked") || (url_vars.hide_avatars == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hideavatar")) {
	if ((url_vars.hideavatar == "checked") || (url_vars.hideavatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hideAvatar")) {
	if ((url_vars.hideAvatar == "checked") || (url_vars.hideAvatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}

if (url_vars.hasOwnProperty("clear_chat")) {
	if ((url_vars.clear_chat == "checked") || (url_vars.clear_chat == "true"))
		$("#clearNotification").prop("checked", true);
	else {
		$("#clearNotification").prop("checked", false);
	} 
}

if (url_vars.hasOwnProperty("clearchat")) {
	if ((url_vars.clearchat == "checked") || (url_vars.clearchat == "true"))
		$("#clearNotification").prop("checked", true);
	else {
		$("#clearNotification").prop("checked", false);
	} 
}

if (url_vars.hasOwnProperty("clearChat")) {
	if ((url_vars.clearChat == "checked") || (url_vars.clearChat == "true"))
		$("#clearNotification").prop("checked", true);
	else {
		$("#clearNotification").prop("checked", false);
	} 
}

if (url_vars.hasOwnProperty("bear")) {
		$("#exportOption").val(url_vars.bear + "Bear");
}
if (url_vars.hasOwnProperty("porridge")) {
	var selectedPorridge = exportFormat

	$.each(exportFormats, function(index, obj){
		if (url_vars.porridge == obj.shortDesc.replace(' Porridge', '').toLowerCase()) {
			selectedPorridge = obj.id;
		}
	});	
	
	$("#exportFormat").val(selectedPorridge);
}


function getUrlVars() {
    // Function found at http://stackoverflow.com/questions/4656843/jquery-get-querystring-from-url#answer-4656873
    var vars = [], hash;
    var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for(var i = 0; i < hashes.length; i++)
    {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
}


//////////////////////////////////////////////////////////////////////
////   Login events      /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
$('#userApiDetailsForm').unbind('click')
$('#userApiDetailsForm').on('click', '.div-fetchData', function(event){
if (debug) console.log('debug #userApiDetailsForm (Fetch Data)');
	/* The user manually submitted the API connection form. */
    userId   = $('#userId').val();
    apiToken = $('#apiToken').val();
	groupId = $('#groupId').val();
	maxMembersToFetch = $('#maxMembersToFetch').val();
	hideAvatar = $('#hideAvatar')[0].checked;
	clearNotification = $('#clearNotification')[0].checked;
	exportOption = $('#exportOption').val()
    exportFormat = $('#exportFormat').val()
	if (debugShowObject) console.log('exportFormat: ' + exportFormat );

	if (groupId.toLowerCase() == 'party') {
		groupId = 'party'
	} else if (groupId.toLowerCase() == 'tavern') {
		groupId = 'tavern'
	} else {
		groupId = groupId.slice(-36)
	};
	if (debug) console.log('Group ID is ' +  groupId);
	
	//Clear as submit option used and group may of change
	if ((groupId.length < 36) && !((groupId == 'tavern') || (groupId == 'party'))) {
		$('.div-getGroup').trigger('click');
	} else {
		$('#MAIN').html('');
		fetchData();
	}
});

$('#userApiDetailsForm').on('click', '.div-getGroup', function(event){
if (debug) console.log('debug #userApiDetailsForm (getGroup)');

	/* The user manually submitted the API connection form. */
    userId   = $('#userId').val();
    apiToken = $('#apiToken').val();

	groupDropDownShow = true;
	fetchGroupForUser();
	
	
});


$('#userApiDetailsForm').on('click', '.div-switchToManual', function(event){
if (debug) console.log('debug #userApiDetailsForm (switchToManual)');

	/* The user manually submitted the API connection form. */
 	groupDropDownShow = false;
	enableShowHideToggling()
});



//////////////////////////////////////////////////////////////////////
////   Data Fetch Functions   //////////////////////////////
//////////////////////////////////////////////////////////////////////
function fetchGroupForUser() {
    if (debug) console.log('Fetch Groups for User');
	
    $('#loading #serverName').text(serverName);
    $('#loading .good').show();
    $('#loading .bad' ).hide();
	
	groupForUser = []; // clear from previous fetches

    var ajaxRunningCount = 1; // drops to 0 when all calls have succeeded

	$('#loading #statusFetch').text('Getting Joined Guilds/Party List');
	var newData = { "type": "guilds,party" }
    $.ajax({
        url: serverUrl + serverPathGroup,
        type: 'GET',
		contentType: 'application/json',
		data: newData,
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchGroupForUserSuccess,
        error: fetchFailure
    });
	
	function fetchFailure(data) {
        if (debug) console.log('debug fetchFailure start');
        $('#loading .good').hide();
        $('#loading .bad' ).show();
        $('#documentationAndForm').show(); // in case user has done a re-fetch
        $('#documentationAndFormClose').hide();
		console.log(data)
        if (debug) console.log('debug fetchGroupForUserSuccess not found');
    }
	
	function fetchGroupForUserSuccess(data) {
        if (debug) console.log('debug parseData Groups For User Success Start success start');
		 $('#loading .good').hide();
        groupForUser = data.data;
		
		if (debugShowObject) console.log(groupForUser);

		
        ajaxRunningCount--;
		
		if (ajaxRunningCount == 0) {
			enableShowHideToggling()
		}
    }
	
}

function fetchData() {
    if (debug) console.log('debug fetchData start');
	if (debug) console.log('Group ID is ' +  groupId);
    $('#loading #serverName').text(serverName);
    $('#loading .good').show();
    $('#loading .bad' ).hide();
	$('#loading .error' ).hide();
	$('#loading .dblClickError' ).hide();
	
	lastListMemberId = '' // clear from previous fetches
	members = []; // clear from previous fetches
	memberListToFetch = [];  // clear from previous fetches
	
	var listToFetch = [];
	var lastMemberIndex = 0 // clear from previous fetches
	var ajaxTryAgain = 0;
	var ajaxTryAgainNeed = 0;
		
    var ajaxRunningCount = 3; // drops to 0 when all calls have succeeded
	var ajaxRunningCount_Group = 1;

	
    // fetch the user's own content (guilds, parties):
	$('#loading #statusFetch').text('Asking for User Data');
    $.ajax({
        url: serverUrl + serverPathUser,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchUserSuccess,
        error: fetchFailure
    });

    // fetch the site-wide content (gear names and stats, etc):
	$('#loading #statusFetch').text('Asking for Generic Content');
    $.ajax({
        url: serverUrl + serverPathContent,
        type: 'GET',
        dataType: 'json',
        cache: true,
        success: fetchContentSuccess,
        error: fetchFailure
    });
	

	function fetchFailure() {
        if (debug) console.log('debug fetchFailure start');
        $('#loading .good').hide();
        $('#loading .bad' ).show();
        $('#documentationAndForm').show(); // in case user has done a re-fetch
        $('#documentationAndFormClose').hide();
        if (debug) console.log('debug fetchFailure end');
    }
	function fetchUserSuccess(data) {
        if (debug) console.log('debug parseData User success start');
		$('#loading #statusFetch').text('Fetching User Data');
        user = data.data;
		
		userIsAdmin = false;
		if (user.contributor != undefined) {
			if (user.contributor.admin) userIsAdmin = true
		}

		//Check Id given is the party id.
		if (user.party != undefined) if (user.party._id == groupId) groupId = 'party'
		
		
		//$$$ Check if group id is listed in guilds?
		if (groupId  !=  'party') {
			fetchGuildData();
		} else {
			if (user.party) fetchPartyData(); 
		}

		if (debugShowObject) console.log(user);
        ajaxRunningCount--;
        if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
            fetchMemberList();
        }
    }
	function fetchContentSuccess(data) {
        if (debug) console.log('debug parseData Content success start');
		$('#loading #statusFetch').text('Fetching Generic Content');
        content = data.data;
		if (debugShowObject) console.log(content);
        ajaxRunningCount--;
        if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
            fetchMemberList();
        }
    }

  
	function fetchGuildData() {
		if (debug) console.log('debug parseData Guild Data start');
		
		$.ajax({
			url: serverUrl + serverPathGroup + '/' + groupId,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
			},
			success: fetchGuildSuccess,
			error: fetchFailure  
		});
	}
		
	function fetchGuildSuccess(data) {
		if (debug) console.log('debug Guild Sucess data start');
		group = data.data;
		if (debugShowObject) console.log(group);
		fetchChallengeGroupData(group._id) //Challenge data requires actual Id
		
		//if (debugShowObject) console.log(groups);
		ajaxRunningCount_Group--; 
		if (ajaxRunningCount + ajaxRunningCount_Group  === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}		
	
	function fetchPartyData() {
		if (debug) console.log('debug parseData Party Data start');
		
		$.ajax({
			url: serverUrl + serverPathParty,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
			},
			success: fetchPartySuccess,
			error: fetchFailure 
		});
	}	
	
	function fetchPartySuccess(data) {
		if (debug) console.log('debug Party Sucess data start');
		party = data.data;
		group = party;
		if (debugShowObject) console.log(party);
		fetchChallengeGroupData(group._id) //Challenge data requires actual Id
		ajaxRunningCount_Group--; 
		if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}	

	function fetchChallengeGroupData(actualGroupId) {
		if (debug) console.log('debug parseData Challenge Data start');
		
		$('#loading #statusFetch').text('Asking for Challenge Data for Group');
		$.ajax({
			url: serverUrl + serverPathChallengeGroup + '/' + actualGroupId,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: fetchChallengeGroupSuccess,
			error: fetchFailure
		});
	}	
	
	function fetchChallengeGroupSuccess(data) {
        if (debug) console.log('debug parseData Challenge Group success start');
		$('#loading #statusFetch').text('Fetching Challenge Data for the Group');
        challengeGroup = data.data;
		if (debugShowObject) console.log(challengeGroup);
        ajaxRunningCount--;
        if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
            fetchMemberList();
        }
    }  	
		
	function fetchMemberList() {
		if (debug) console.log('debug Member List start');
		$('#loading #statusFetch').text('Asking for Member List (' + memberListToFetch.length + ' so far)');
		var completeUrl = '';

		if  (maxMembersToFetch == 0) {
			fetchMembers()
		} else {
			if (lastListMemberId == '') {
				completeUrl = serverUrl + serverPathGroup + '/' + groupId + serverPathGroupMemberPart ;
			} else {
				completeUrl = serverUrl + serverPathGroup + '/' + groupId + serverPathGroupMemberPart + '?lastId=' + lastListMemberId;
			}
			

			if (debugShowObject) console.log(completeUrl);	
			$.ajax({
				url: completeUrl,
				type: 'GET',
				dataType: 'json',
				cache: false,
				beforeSend: function(xhr){
						xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
						xhr.setRequestHeader('x-api-key',  apiToken);
				},
				success: fetchMemberListSuccess,
				error: fetchMemberListFailure
			});
		}
	}

		
		
	function fetchMemberListSuccess(data) {
		if (debug) console.log('debug Member List Sucess start');
		memberListToFetch = memberListToFetch.concat(data.data);
		
		if (memberListToFetch.length > 0 || maxMembersToFetch == 0) {
			if (memberListToFetch[memberListToFetch.length -1]._id == lastListMemberId || memberListToFetch.length >= maxMembersToFetch || memberListToFetch.length == group.memberCount) {
			//The extra test as sometimes the Member Count is not accurate
				if (group.memberCount < memberListToFetch.length || memberListToFetch[memberListToFetch.length -1]._id == lastListMemberId ) {
					$('#loading #groupDetail').text(group.name + ' (Group Id: ' + groupId + ')');
					$('#loading #groupDetailCount').text(' (Stated: ' + group.memberCount + ' Estimated: ' + memberListToFetch.length + ')');
					$('#loading .error' ).show();
					if ((memberListToFetch.length%group.memberCount == 0) && group.memberCount > 1) $('#loading .dblClickError' ).show();
				}
				if (debugShowObject) console.log(memberListToFetch);
				ajaxTryAgain = 0; //Clear out previous count.
				fetchMembers()		 
			} else {
				//Still more members to get
				lastListMemberId = memberListToFetch[memberListToFetch.length -1]._id;
				fetchMemberList()
			}	
		} else {
			//No members in group error
			if (debug) console.log('debug Member List No one in list... WHERE DID EVERYONE GO????');
		}
	}	
		
	function fetchMemberListFailure() {
		if (debug) console.log('debug Member List Fail Start');
		ajaxTryAgain++
		if (ajaxTryAgain < ajaxTryAgainMax) {
			fetchMemberList()
		} else {
			fetchFailure()
		}
	}
		
	function fetchMembers(){
		var timeoutPeriod = 0;
		
		if (ajaxTryAgainNeed > 0)  { 
			if (debug) console.log('debug MEMBER DATA - Looks like we missed some stray ducks (' + ajaxTryAgainNeed + ')');
	
			//need to find the missing members
			var ajaxTryAgainList = []
			
			$.each(memberListToFetch, function(index, obj){
				if (members[obj.id] == undefined) {
					ajaxTryAgainList.push(obj)
				}
			});
			
			ajaxTryAgainNeed = 0 
			
			ajaxTryAgain++ 
			
			listToFetch = ajaxTryAgainList
			
		} else {
			if (debug) console.log('debug MEMBER DATA - oK getting ready the first list (' + lastMemberIndex + ')');
	
			//Do a quick loop so we can check if leader is needed $$$I'm sure there is a better way but it is late
			memberListToFetch_idOnly = []
			$.each(memberListToFetch, function(index, obj){
				memberListToFetch_idOnly.push(obj.id)
			});
			//Add Group owner and Quest owner if not in list
			if (memberListToFetch_idOnly.indexOf(group.leader.id) < 0){
				memberListToFetch.push({_id: group.leader.id, id: group.leader.id, profile: {name: 'unknownLeaderName'}})
				memberListToFetch_idOnly.push(group.leader.id)
			}
			if (groupId == 'party'){
				if (group.quest.leader != undefined){
					if (memberListToFetch_idOnly.indexOf(group.quest.leader) < 0) {
						memberListToFetch.push({_id: group.quest.leader, id: group.quest.leader, profile: {name: 'unknownQuestOwner'}})
						memberListToFetch_idOnly.push(group.quest.leader)
					}
				}
			}
			
			listToFetch = memberListToFetch
		}
		
		if (debugShowObject) console.log(listToFetch.length)
		lastMemberIndex = 0
		
		
		$.each(listToFetch, function(index, obj){
			
			timeoutPeriod = Math.floor(index / 1500)  * 120000
			
			
			setTimeout(function () {
				$('#loading #statusFetch').text('Asking for Member Data ... (This can take a while - ' + Math.ceil(index / 1500) + ' group of 1500)'); 
				if (debug) console.log('debug MEMBER DATA -Yes we are finally here folks (' + obj.id + ' Index: + ' + index + ')');
				$.ajax({
					url: serverUrl + serverPathMemberProfilePart + '/' + obj.id,
					type: 'GET',
					dataType: 'json',
					cache: false,
					beforeSend: function(xhr){
							xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
							xhr.setRequestHeader('x-api-key',  apiToken);
					},
					success: fetchMemberSuccess,
					error: fetchMemberFail
				});
			}, timeoutPeriod);
		});
	}
		
		
	function fetchMemberFail() {

		if (debug) console.log('debug Member Fail Fetch for ' + (lastMemberIndex+1))
		
		if (ajaxTryAgain < ajaxTryAgainMax) {
			ajaxTryAgainNeed++
		}
		
		fetchMemberComplete()
			
	}
			
			
	function fetchMemberSuccess(data) {
		if (debug) console.log('debug Member Sucess data start ' +  lastMemberIndex + '  id: ' + data.data._id);
		var friendlyMemberIndex = lastMemberIndex + 1
		$('#loading #statusFetch').text('Fetching Member '  +  friendlyMemberIndex);
		
		members[data.data._id] = data.data;

		fetchMemberComplete()
	}	
	
	function fetchMemberComplete() {
		if (lastMemberIndex == listToFetch.length-1) { // all ajax calls have finished
			if (debug) console.log('debug Lost ducks ' + (ajaxTryAgainNeed))
			if (ajaxTryAgainNeed > 0) {
				fetchMembers()
			} else {
				if (ajaxTryAgain < ajaxTryAgainMax) {
					$('#loading #statusFetch').text('Preparing to Display the Data');
					if (debugShowObject) console.log(members);
					parseData();
				} else {
					fetchFailure()
				}
			}
		} else {
			lastMemberIndex++
		}	
	}

}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
////  Post functions  				    //////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// All post functions are implemented serial as they are unreliable when performed in parallel.

//////////////////////////////////////////////////////////////////////
////  Toggle Leader	Only Challenge	    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postToggleLeaderOnlyChallenge(newValue) {
	if (debug) console.log('debug postToggleLeaderOnlyChallenge start');
	var displayValue = String(newValue)
	if (confirm('Are you sure you wish to change the setting Leader can Only Create Challenges to : ' + displayValue + '?')){
		postNextToggleLeaderOnlyChallenge()
	} else {
		alert('Action cancelled')
		return;
	}
	
	
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextToggleLeaderOnlyChallenge(){
		var newData = {leaderOnly: {challenges: newValue}}
		if (debugShowObject) console.log(newData);
		urlToPost = serverUrl + serverPathGroup + '/' + groupId //+ '?leader.id=' + obj[uuidIndex] 
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'PUT',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postToggleLeaderOnlyChallengeSuccess,
			error: postToggleLeaderOnlyChallengeFailure
		});		
	}
		

	
	function postToggleLeaderOnlyChallengeFailure(data){
		if (debug) console.log('debug postToggleLeaderOnlyChallengeFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Toggle Leader Only Challenges \n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
				
		fetchData()
	}


	function postToggleLeaderOnlyChallengeSuccess(data){
		if (debug) console.log('debug postToggleLeaderOnlyChallengeSuccess start');
		if (debugShowObject) console.log(data);
		alert('Toggle Leader Only Challenge has changed.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	

}


//////////////////////////////////////////////////////////////////////
////  Change Leader					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postChangeLeader(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postChangeLeader start');
	var urlToPost = ''	
	var newData = {}
	var actionItem = ''
	var actionIndex = 0
	
	
	if (rowData.length == 0){
		if (debug) console.log('debug no use selected');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else if (rowData.length > 1) {
		if (debug) console.log('debug too many leaders');
		alert('Too many row selected.\nPlease select a single row before trying again.');
		return;
	} else if (rowData[0][uuidIndex]=='system') {
		if (debug) console.log('debug selected system as leaders');
		alert('System User Selected.\nPlease select a different row before trying again.');
		return;
	} else if (rowData[0][uuidIndex]==group.leader.id) {
		if (debug) console.log('debug selected system as leaders');
		alert('User is already leader.\nPlease select a different row before trying again.');
		return;
	} else {
		if (debugShowObject) console.log( rowData );
		
		actionIndex = rowData[0].length
		actionItem = rowData[0][nameIndex]
		if (actionItem.substring(0,3) == '<a '){
			actionItem = actionItem.substring(actionItem.indexOf('>')+1,actionItem.length - ('</a>').length)
		}
		rowData[0].push(actionItem)
		
		if (confirm('Are you sure you wish to change the leader to ' + rowData[0][actionIndex] + '?\n\nThere is no undo!')){
			obj = rowData[0]
			
			postNextChangeLeader()
		} else {
			alert('Action cancelled')
			return;
		}
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextChangeLeader(){
		obj = rowData[0]
		var newData = {leader: obj[uuidIndex]}
		urlToPost = serverUrl + serverPathGroup + '/' + groupId 
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'PUT',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postChangeLeaderSuccess,
			error: postChangeLeaderFailure
		});		
	}
		

	
	function postChangeLeaderFailure(data){
		if (debug) console.log('debug postChangeLeaderFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
				
		fetchData()
	}


	function postChangeLeaderSuccess(data){
		if (debug) console.log('debug postChangeLeaderSuccess start');
		if (debugShowObject) console.log(data);
		alert('Leader has changed.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	

}


//////////////////////////////////////////////////////////////////////
////  Remove User					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postRemoveUser(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postRemoveUser start');
	var urlToPost = ''	
	var removeUserList = ''
	var actionItem = ''
	var actionIndex = 0
	var index = 0
	var removeMessage = ''
	var pmMessage = false
	var loopList = []
	
	if (rowData.length == 0){
		if (debug) console.log('debug no users to remove');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		if (debugShowObject) console.log( rowData );
		
		//get UniqueRows
		for(var i = 0; i < rowData.length; i++) {
			notInLoop = true
			
			if ((rowData[i][uuidIndex] != userId) && (rowData[i][uuidIndex] != 'system')) {
				for(var j = 0; j < loopList.length; j++) {
					if (rowData[i][uuidIndex] == loopList[j][uuidIndex]) {
						notInLoop = false
						break;
					}
					
				}
			
				if (notInLoop) {
					loopList.push(rowData[i])
				}
			} else {
				alert('Ensure rows selected to not include yourself or the System user.\n\nAction Cancelled.')
				return; //Is this naughty?
			}
		}
				
		
		//Check if message to be sent
		var optionalMessage = 'Sorry I needed to remove from the '
		if (groupId == 'party') {
			optionalMessage += 'party!'
		} else {
			optionalMessage += 'guild!'
		}
		
		removeMessage = prompt('Please enter your optional email message to be sent to the users being removed.\n\n' + infoMessage , optionalMessage)

		removeMessage = removeMessage.replace(/{nl}/g,'\n');

		if (removeMessage.trim() != '') if (confirm('Do you wish to send the message as a private message?')) pmMessage = true


		actionIndex = loopList[0].length
		
		for(var i = 0; i < loopList.length; i++)
		{
			actionItem = loopList[i][nameIndex]
			if (actionItem.substring(0,3) == '<a '){
				actionItem = actionItem.substring(actionItem.indexOf('>')+1,actionItem.length - ('</a>').length)
			}
			removeUserList += '\n\u2022  ' + actionItem
			loopList[i].push(actionItem)
		}
		
		if (removeMessage != null){
			if (confirm('Are you sure you wish to remove the selected users?' + removeUserList + '\n\nThere is no undo!')){
				removeUserList = ''
				postNextRemoveUser()
			} else {
				alert('Action cancelled')
				return;
			}
		} else {
			alert('Action cancelled')
			return;
		}
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextRemoveUser(){
		$('#posting .good').show();
		
		obj = loopList[index]
		urlToPost = serverUrl + serverPathGroup + '/' + groupId + serverPathRemoveUser + '/' + obj[uuidIndex] + '?message=' + removeMessage
		$('#posting #statusPost').text('Removing ' + obj[actionIndex] );
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postRemoveUserSuccess,
			error: postRemoveUserFailure
		});		
	}
		

	
	function postRemoveUserFailure(data){
		if (debug) console.log('debug postRemoveUserFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postRemoveUserCheckCompleted()
	}


	function postRemoveUserSuccess(data){
		if (debug) console.log('debug postRemoveUserSucess start');
		$('#posting #statusPost').text('Successfully Removed ' + obj[actionIndex] );
		if (debugShowObject) console.log(data);
		removeUserList += '\n\u2022  ' + obj[actionIndex]  
		
		if (pmMessage) {
			postRemoveUserSendPM()
		} else {
			index++
			postRemoveUserCheckCompleted()
		}
	}
	
	function postRemoveUserSendPM() {
		var privateMessage = '`You have been removed from the '
		if (groupId == 'party') {
			privateMessage = privateMessage + 'party'
		} else {	
			privateMessage = privateMessage + 'guild'
		}
		privateMessage = privateMessage + ' "' + group.name + '".` ' + removeMessage
		var newData = {message: privateMessage, toUserId: obj[uuidIndex]}
		urlToPost = serverUrl + serverPathMessageUser 
		$('#posting #statusPost').text('Messaging ' + obj[actionIndex] );
		if (debugShowObject) console.log(urlToPost);
		if (debugShowObject) console.log(newData);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postRemoveUserSendPMSuccess,
			error: postRemoveUserSendPMFailure
		});		
	}
	
	function postRemoveUserSendPMFailure(data){
		if (debug) console.log('debug postRemoveUserSendPMFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postRemoveUserCheckCompleted()
	}


	function postRemoveUserSendPMSuccess(data){
		if (debug) console.log('debug postRemoveUserSendPMSuccess start');
		$('#posting #statusPost').text('Successfully Messaged ' + obj[actionIndex] );
		if (debugShowObject) console.log(data);
		index++
		
		postRemoveUserCheckCompleted()
	}
	
	function postRemoveUserCheckCompleted() {
		if (index === loopList.length){
			$('#posting .good').hide();
			if (debugShowObject) console.log(removeUserList);
			alert('The following users have been removed:' + removeUserList + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextRemoveUser()
		}		
	
	}
}


//////////////////////////////////////////////////////////////////////
////  Post Message					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postMessageUser(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postMessageUser start');
	if (debugShowObject) console.log(rowData)
	var urlToPost = ''	
	var actionNotificationList = ''
	var actionItem = ''
	var actionIndex = 0
	var index = 0
	var privateMessage = ''
	var loopList = []
	
	
	if (rowData.length == 0){
		if (debug) console.log('debug no users to remove');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		if (debugShowObject) console.log( rowData );
		//Check if message to be sent
		var optionalMessage = 'Thank You!'
		
		privateMessage = prompt('Please enter your private message to be sent to the users selected:\n\n' + warningMessage + '\n\n' + infoMessage, optionalMessage)

		privateMessage = privateMessage.replace(/{nl}/g,'\n');


		//get UniqueRows
		for(var i = 0; i < rowData.length; i++) {
			notInLoop = true
			
			if ((rowData[i][uuidIndex] != userId) && (rowData[i][uuidIndex] != 'system')) {
				for(var j = 0; j < loopList.length; j++) {
					if (rowData[i][uuidIndex] == loopList[j][uuidIndex]) {
						notInLoop = false
						break;
					}
					
				}
			
				if (notInLoop) {
					loopList.push(rowData[i])
				}
			} else {
				alert('Ensure rows selected to not include yourself or the System user.\n\nAction Cancelled.')
				return; //Is this naughty?
			}
		}
		
		
		actionIndex = loopList[0].length
		
		for(var i = 0; i < loopList.length; i++)
		{
			actionItem = loopList[i][nameIndex]
			if (actionItem.substring(0,3) == '<a '){
				actionItem = actionItem.substring(actionItem.indexOf('>')+1,actionItem.length - ('</a>').length)
			}
			actionNotificationList += '\n\u2022  ' + actionItem
			loopList[i].push(actionItem)
		}
		
		if (privateMessage != null){
			if (confirm('Are you sure you wish to send\n\n' + privateMessage + '\n\n to the selected users?' + actionNotificationList + '\n\nThere is no undo!')){
				actionNotificationList = ''
				postNextMessageUser()
			} else {
				alert('Action cancelled')
				return;
			}
		} else {
			alert('Action cancelled')
			return;
		}

	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextMessageUser(){
		$('#posting .good').show();
		
		obj = loopList[index]
		var newData = {message: privateMessage, toUserId: obj[uuidIndex]}
		urlToPost = serverUrl + serverPathMessageUser //+ '/' + obj[uuidIndex] + '?message=' + privateMessage
		$('#posting #statusPost').text('Messaging ' + obj[actionIndex] );
		if (debugShowObject) console.log(urlToPost);
		if (debugShowObject) console.log(newData);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postMessageUserSuccess,
			error: postMessageUserFailure
		});		
	}
		

	
	function postMessageUserFailure(data){
		if (debug) console.log('debug postMessageUserFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postMessageUserCheckCompleted()
	}


	function postMessageUserSuccess(data){
		if (debug) console.log('debug postMessageUserSucess start');
		$('#posting #statusPost').text('Successfully Messaged ' + obj[actionIndex] );
		if (debugShowObject) console.log(data);
		actionNotificationList += '\n\u2022  ' + obj[actionIndex]  
		index++
		
		postMessageUserCheckCompleted()
	}
	
	function postMessageUserCheckCompleted(){
		if (index === loopList.length){
			$('#posting .good').hide();
			if (debugShowObject) console.log(actionNotificationList);
			alert('The following users have been messaged:' + actionNotificationList + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextMessageUser()
		}		
	
	}
}

//////////////////////////////////////////////////////////////////////
////  Give Card					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postGiveCard(cardType, rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postGiveCard start');
	var urlToPost = ''	
	var cardUserList = ''
	var actionItem = ''
	var actionIndex = 0
	var index = 0
	
	
	if (rowData.length == 0) {
		if (debug) console.log('debug nothing to transform');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		actionIndex = rowData[0].length
		if (debugShowObject) console.log( rowData );
		//Check if enough Gold items $$$
		if (user.stats.gp < (rowData.length * cardItems[cardType].cost)) {
			alert('Not enough gold. ' +  (rowData.length * cardItems[cardType].cost) + ' gold required.\nPlease ensure enough gold before trying again.\n\n(Re-Fetch Data if necessary)');
			return;
		} else {
			postNextGiveCard()
		}
		
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextGiveCard(){
		$('#posting .good').show();

		//Check if already card? $$$
		obj = rowData[index]
		
		actionItem = obj[nameIndex]
		if (actionItem.substring(0,3) == '<a '){
			actionItem = actionItem.substring(actionItem.indexOf('>')+1,actionItem.length - ('</a>').length)
		}
		obj.push(actionItem)
				
		urlToPost = serverUrl + serverPathCastSkill + '/' + cardType + '?targetId=' + obj[uuidIndex]
		$('#posting #statusPost').text('Giving Card to ' + obj[actionIndex] );
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postGiveCardSuccess,
			error: postGiveCardFailure
		});		
	}
		
	function postGiveCardFailure(data){
		if (debug) console.log('debug postGiveCardFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index = rowData.length; // Don't bother trying anymore
		
		postGiveCardCheckCompleted()
	}

	function postGiveCardSuccess(data){
		if (debug) console.log('debug postUseCardSucess start');
		if (debugShowObject) console.log(data);
		$('#posting #statusPost').text('Successfully Gave Card to ' + obj[actionIndex] );
		cardUserList += '\n\u2022  ' + data.data.partyMembers[0].profile.name  
		index++
		
		postGiveCardCheckCompleted()
		
	}
		
	function postGiveCardCheckCompleted(){
		if (index === rowData.length){
			if (debugShowObject) console.log(cardUserList);
			$('#posting .good').hide();
			alert('The following users have been given a '+ cardItems[cardType].name +':' + cardUserList + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextGiveCard()
		}		
	
	}
}


//////////////////////////////////////////////////////////////////////
////  Transform Member				    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postTransformMember(transformItem, rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postTransformMember start');
	var urlToPost = ''	
	var transformedUserList = ''
	var actionItem = ''
	var actionIndex = 0
	var index = 0
	
	
	if (rowData.length == 0){
		if (debug) console.log('debug nothing to transform');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		actionIndex = rowData[0].length
		if (debugShowObject) console.log( rowData );
		//Check if enough transformational items $$$
		postNextTransformMember()
		
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextTransformMember(){
		$('#posting .good').show();

		//Check if already transformed? $$$
		obj = rowData[index]
		
		actionItem = obj[nameIndex]
		if (actionItem.substring(0,3) == '<a '){
			actionItem = actionItem.substring(actionItem.indexOf('>')+1,actionItem.length - ('</a>').length)
		}
		obj.push(actionItem)
				
		urlToPost = serverUrl + serverPathCastSkill + '/' + transformItem + '?targetId=' + obj[uuidIndex]
		$('#posting #statusPost').text('Transforming ' + obj[actionIndex] );
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postTransformMemberSuccess,
			error: postTransformMemberFailure
		});		
	}
		

	
	function postTransformMemberFailure(data){
		if (debug) console.log('debug postTransformMemberFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[actionIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postTransformMemberCheckCompleted()
	}


	function postTransformMemberSuccess(data){
		if (debug) console.log('debug postTransformMemberSucess start');
		if (debugShowObject) console.log(data);
		$('#posting #statusPost').text('Successfully Transformed ' + obj[actionIndex] );
		transformedUserList += '\n\u2022  ' + data.data.partyMembers[0].profile.name  
		index++
		
		postTransformMemberCheckCompleted()
	}
	
	function postTransformMemberCheckCompleted(){
		if (index === rowData.length){
			if (debugShowObject) console.log(transformedUserList);
			$('#posting .good').hide();
			alert('The following users are transformed by '+ transformItems[transformItem].name +':' + transformedUserList + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextTransformMember()
		}		
	
	}
}


//////////////////////////////////////////////////////////////////////
////  Post Chat				    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postChat() {
	if (debug) console.log('debug postChat start');
	var urlToPost = ''	
	var newData = {}
	var chatMessage = ''

	//Check if message to be sent
	var optionalMessage = 'Thank You!'
		
	chatMessage = prompt('Please enter your chat message to be posted.\n\n' + warningMessage + '\n\n' + infoMessage, optionalMessage)

	chatMessage = chatMessage.replace(/{nl}/g,'\n');


	if (chatMessage != null){
		if (confirm('Are you sure you wish to post\n\n' + chatMessage + '\n\nto chat?')){
			postNextPostChat()
		} else {
			alert('Action cancelled')
			return;
		}
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextPostChat(){
		var newData = {message: chatMessage}
		urlToPost = serverUrl + serverPathGroup + '/' + groupId + serverPathPostChatPart
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postChatSuccess,
			error: postChatFailure
		});		
	}
		

	
	function postChatFailure(data){
		if (debug) console.log('debug postChatFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH POSTING CHAT MESSAGE\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		
		fetchData()
	}


	function postChatSuccess(data){
		if (debug) console.log('debug postChatSuccess start');
		if (debugShowObject) console.log(data);
		alert('Chat Posted.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	

}

//////////////////////////////////////////////////////////////////////
////  Accept Quest					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postQuestAccept() {
	if (debug) console.log('debug postQuestAccept start');
	var urlToPost = ''	
	var newData = {}

	if (confirm('Are you sure you wish to accept the quest?\n\nThere is no undo without aborting the quest!')){
		postNextQuestAccept()
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextQuestAccept(){
		urlToPost = serverUrl + serverPathQuestAccept
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postQuestAcceptSuccess,
			error: postQuestAcceptFailure
		});		
	}
		

	
	function postQuestAcceptFailure(data){
		if (debug) console.log('debug postQuestAcceptFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Accepting Quest\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nYour data will now be refreshed.');	
		
		fetchData()
	}


	function postQuestAcceptSuccess(data){
		if (debug) console.log('debug postQuestAcceptSuccess start');
		if (debugShowObject) console.log(data);
		alert('Quest Accepted.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	

}



//////////////////////////////////////////////////////////////////////
////  Reject Quest					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postQuestReject() {
	if (debug) console.log('debug postQuestReject start');
	var urlToPost = ''	
	var newData = {}

	if (confirm('Are you sure you wish to reject the quest?\n\nThere is no undo without aborting the quest!')){
		postNextQuestReject()
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextQuestReject(){
		urlToPost = serverUrl + serverPathQuestReject
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postQuestRejectSuccess,
			error: postQuestRejectFailure
		});		
	}
		

	
	function postQuestRejectFailure(data){
		if (debug) console.log('debug postQuestRejectFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Rejecting Quest\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nYour data will now be refreshed.');	
		
		fetchData()
	}


	function postQuestRejectSuccess(data){
		if (debug) console.log('debug postQuestRejectSuccess start');
		if (debugShowObject) console.log(data);
		alert('Quest Rejected.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	

}



//////////////////////////////////////////////////////////////////////
////  (Force) Start Quest					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postQuestStart() {
	if (debug) console.log('debug postQuestStart start');
	var urlToPost = ''	
	var newData = {}

	if (confirm('Are you sure you wish to force start the quest?\n\nNo other members will be able to join the quest.')){
		postNextQuestStart()
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextQuestStart(){
		urlToPost = serverUrl + serverPathQuestStart
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postQuestStartSuccess,
			error: postQuestStartFailure
		});		
	}
		

	
	function postQuestStartFailure(data){
		if (debug) console.log('debug postQuestStartFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Starting Quest\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nYour data will now be refreshed.');	
		
		fetchData()
	}


	function postQuestStartSuccess(data){
		if (debug) console.log('debug postQuestStartSuccess start');
		if (debugShowObject) console.log(data);
		alert('Quest Started.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	
}

//////////////////////////////////////////////////////////////////////
////  Leave  Quest					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postQuestLeave() {
	if (debug) console.log('debug postQuestLeave start');
	var urlToPost = ''	
	var newData = {}

	if (confirm('Are you sure you wish to leave the quest?\n\nYou will not gain the rewards of this quest or be able to join a quest till a new one is started.')){
		postNextQuestLeave()
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextQuestLeave(){
		urlToPost = serverUrl + serverPathQuestLeave
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postQuestLeaveSuccess,
			error: postQuestLeaveFailure
		});		
	}
		

	
	function postQuestLeaveFailure(data){
		if (debug) console.log('debug postQuestLeaveFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Leaving Quest\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nYour data will now be refreshed.');	
		
		fetchData()
	}


	function postQuestLeaveSuccess(data){
		if (debug) console.log('debug postQuestLeaveSuccess start');
		if (debugShowObject) console.log(data);
		alert('Quest Left.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	
}



//////////////////////////////////////////////////////////////////////
////  Abort Quest					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postQuestAbort() {
	if (debug) console.log('debug postQuestAbort start');
	var urlToPost = ''	
	var newData = {}

	if (confirm('Are you sure you wish to abort the quest?\n\nAll progress will be lost and the scroll will be return to the quest owner.')){
		postNextQuestAbort()
	} else {
		alert('Action cancelled')
		return;
	}
	
	//This is done like this as receive ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextQuestAbort(){
		urlToPost = serverUrl + serverPathQuestAbort
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postQuestAbortSuccess,
			error: postQuestAbortFailure
		});		
	}
		

	
	function postQuestAbortFailure(data){
		if (debug) console.log('debug postQuestAbortFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH Aborting Quest\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nYour data will now be refreshed.');	
		
		fetchData()
	}


	function postQuestAbortSuccess(data){
		if (debug) console.log('debug postQuestAbortSuccess start');
		if (debugShowObject) console.log(data);
		alert('Quest Aborted.\n\nYour data will now be refreshed')
		
		fetchData() 
	}
	
}


///////////////////////////////////////////////////////////////
////   Clear Notifications                         ////////////
//////////////////////////////////////////////////////////////
function postClearNotification(notifcationList) {
	if (debug) console.log('debug Clear Notifications  Start');
	var urlToPost = ''	
	var index = 0
	var loopList = []
	
	//create an array
	$.each(notifcationList, function(index, obj){
		loopList.push(index)
	});

	if (loopList.length > 0) {
		postNextClearNotification()
	} else {
		checkClearNotification()
	}
	
	function postNextClearNotification(){
	
		obj = loopList[index]
		$('#loading #statusFetch').text('Clear Notifications for ' + notifcationList[obj].name ) ;
		if (debug) console.log('debug Clear Message for  (' + notifcationList[obj].name + ')');
		urlToPost = serverUrl + serverPathGroup + '/' + obj + '/chat/seen' 
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-client', clientId);xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postClearNotificationSuccess,
			error: postClearNotificationFail
		});
			
	}
	
	
	function postClearNotificationFail(data) {
	
		if (debug) console.log('debug Clear Notification Failed for ' + obj)
		if (debugShowObject) console.log(data);
		alert('ERROR WITH  ' +  obj + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		checkClearNotification()
	}
			
			
	function postClearNotificationSuccess(data) {
//		if (debug) console.log('debug Clear Notification Success Start for ' +  lastGuildIndex + '  id: ' + data.data._id);
		if (debugShowObject) console.log(data);
		$('#loading #statusFetch').text('Clear  Notification for  '  +  notifcationList[obj].name);
		
		index++

		checkClearNotification()
	}	
	
	
	function checkClearNotification() {
		if (index === loopList.length){
			$('#loading #statusFetch').text('') //All Done
			$('#loading .good').hide();
			$('#posting .good').hide(); // just to be sure
			$('#documentationAndFormClose').show();
			$('#documentationAndForm').hide();
		} else
		{
			postNextClearNotification()
		}		

	}
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
////  Parse Data					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
function parseData() {
	if (debug) console.log('debug parseData start');
 
    // variables for storing the content:
    var MAIN = {}; // each element defines the HTML for one section on the page
    var TOC  = {}; // each element defines one Table of Contents entry
    var DASHBOARD = {}; // each element defines the HTML for one dashboard tile

	var fetchtime = myDateConverter(new Date(), 'pretty');
	

    collateAndDisplayData(); //This is one function as memberActivty requires both Member and Guild data.

	userDataInHeader();
	groupDataInHeader();

	
	
	//////////////////////////////////////////////////////////////////////
    ////   Display the HTML that the functions have created   ////////////
    //////////////////////////////////////////////////////////////////////
    $('#loading #statusFetch').text('') //All Done
	$('#loading .good').hide();
	$('#posting .good').hide(); // just to be sure
    $('#documentationAndFormClose').show();
    $('#documentationAndForm').hide();
	
	formatAndDisplayDASHBOARD();
    formatAndDisplayTOC();
	
	
	
	if ($('#MAIN')[0].innerHTML.length > 1) {
		//Keep previous table settings
		refreshAndDisplayMAIN();
	} else {
		formatAndDisplayMAIN();
	}

	var newData = {}
	newData[group._id] = {name: group.name, value: true}
	if (clearNotification) postClearNotification(newData)
	
	
	function formatAndDisplayDASHBOARD() {
		// Not required to be changed. Section controlled by Sections defined above.
		var html = '<ul>';
		var valueToDisplay = ''
		
		$.each(dashboardToDisplay, function(index, obj){
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') == true && groupId == 'party') || (obj.showOnly.includes('leader') == true && ((userId == group.leader.id) || (userIsAdmin)))) {
				var data = obj;
				
				var classes = (data.hidden) ? 'hide' : '';
				html += '<li ';
				if (data.id) {
					// id is needed only if other code will change tile background
					html += 'id="' + data.id + '" ';
				}
				html += 'title="' + data.hoverText + '" ';
				if (data.target) {
					html += 'data-target="' + data.target +
							'" data-closemainsections="true" data-forceopen="true" ' +
							'class="showHideToggle ' + classes + '"';
				}
				
				valueToDisplay = eval(data.value)
				
				html += '><div class="' +
						data.status     + '"><div class="value">' +
						valueToDisplay      + '</div><div class="label">' +
						data.label      + '</div></div></li>';
			}
		});


		html += '</ul><div class="clear"></div>';
		if (debugShowObject) console.log(html);
		$('#DASHBOARD').html(html);
	}

	
	function formatAndDisplayTOC() {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = []
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') == true && groupId == 'party') || (obj.showOnly.includes('leader') == true && ((userId == group.leader.id) || (userIsAdmin)))) {
				if (obj.type != 'heading'){
					keyToAdd = obj.id
				} else {
					keyToAdd = 'HEADING'  
					if (obj.title != '') keyToAdd = keyToAdd + ' ' + obj.title
				}
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';
		for (var i=0,ic=keys.length; i<ic; i++) {
			if (keys[i].match(/^HEADING/)) { // new section in Table of Contents
				var title = keys[i].replace(/^HEADING/, '');
				if (html) {
					html += '</ul></li>'; // close the previous section
				}
				html += '<li>' + title + (title ? ':' : '&nbsp;') + '<ul>';
			}
			else {
				var data = TOC[keys[i]];
				if (! data) {
					continue;
				}
				html += '<li class="showHideToggle" data-target="' +
						data['target'] + '" data-closemainsections="true">' +
						data['title']  + '</li>';
			}
		}
		html += '</ul></li></ul>'; // close the final section, and the parent ul
		$('#TOC').html('<ul id="tableOfContents">' + html +
					   '</ul><div class="clear"></div><hr class="padded" />');
	}

	function formatAndDisplayMAIN() {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = [];
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') == true && groupId == 'party') || (obj.showOnly.includes('leader') == true && ((userId == group.leader.id) || (userIsAdmin)))) {
				keyToAdd = obj.id
				if (obj.type == 'heading') keyToAdd = ''
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';
		var functions = []; // functions to run after HTML code has been loaded
		var functionsPar = []; //Par to be passed in Function
		for (var i=0,ic=keys.length; i<ic; i++) {
			var data = MAIN[keys[i]];
			if (! data) {
				continue;
			}
			html += '<div id="' +
					data.id     + '"><h2>' +
					data.title  + '</h2>' +
					data.html   +
					((data.longContent) ? '<div class="mainSectionClose closer">' +
										  'close / back to top</div>' : '') +
					'</div>';
			if (data['function']) {
				functions.push(data['function']);
				functionsPar.push(data['functionPar']);
			}
		}
		$('#MAIN').html(html);
		// execute any functions that need to be run AFTER the bulk of the
		// HTML has been created:
		$.each(functions, function(index,fn){
			var passPar = functionsPar[index];
			fn(passPar);
		});
		if (sectionOpen && sectionOpen  !=  'documentationAndForm'
						&& sectionOpen  !=  'versionChanges'
		) {
			// reopen the section that the user had open before re-fetching
			// data (except for sections that don't display the user's own data):
			$('#' + sectionOpen).show();
			openRelatedSections();
		}
	}

	function refreshAndDisplayMAIN() {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = [];
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') == true && groupId == 'party') || (obj.showOnly.includes('leader') == true && ((userId == group.leader.id) || (userIsAdmin)))) {
				keyToAdd = obj.id
				if (obj.type == 'heading') keyToAdd = ''
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';		
		var functions = []; // functions to run after HTML code has been loaded
		var functionsPar = []; //Par to be passed in Function
		for (var i=0,ic=keys.length; i<ic; i++) {
			var data = MAIN[keys[i]];
			if (! data) {
				continue;
			}

			html = data.refreshHtml
			$('#' + data.id + ' #' + data.refreshId).html(html)
			
			if (data['function']) {
				functions.push(data['function']);
				functionsPar.push(data['functionPar']);
			}
		}

		// execute any functions that need to be run AFTER the bulk of the
		// HTML has been created:
		$.each(functions, function(index,fn){
			var passPar = functionsPar[index];
			fn(passPar);
		});
		if (sectionOpen && sectionOpen  !=  'documentationAndForm'
						&& sectionOpen  !=  'versionChanges'
		) {
			// reopen the section that the user had open before re-fetching
			// data (except for sections that don't display the user's own data):
			$('#' + sectionOpen).show();
			openRelatedSections();
		}
	}

	openRelatedSections = function() {

	}
	
	function userDataInHeader() {
		var displayName = user.profile.username //renderFormattedText(user.profile.name);
		
		$('#headerExtras').html('<div id="userNameDisplay">' +
				displayName +
				'</div>' +
				'<div id="explanationAndClearLinks">' +
				'<input id="refetch" type="submit" value="' +
				'Re-Fetch Data (last fetched ' + fetchtime + ')" />' +
				'<span id="documentationAndFormToggle" class="showHideToggle" data-target="documentationAndForm" data-linktext="documentation / options" data-closemainsections="true">show documentation / options</span>' +
				'</div>'  				
				
		);
		$('#refetch').click(function(event){
			/* The user clicked on the Re-Fetch My Data button. */
			$(document).unbind('click'); //remove random elements listeners
			fetchData();
		});
	}
	
	function groupDataInHeader() {
		var displayName = group.nameNotPretty;
		var gemAmount = group.balance * 4
		var displayGemAmount = gemAmount + ' <img src="' + imageURL + imageGem + '" alt="' + 'Gem' + '">'
		var displayLeaderName = group.leader.profile.usernameNotPretty + ' (UserId: ' +  group.leader.id + ' Last Active: ' + members[group.leader.id].lastActive.relativeTime + ')';
		var privacyGroup = group.privacy.charAt(0).toUpperCase() + group.privacy.slice(1);
	
		if (groupId == 'party') {
			var displayGroupType = 'Party'
		} else {
			var displayGroupType =  privacyGroup + ' Guild ' + '(Id: <a href="' + serverHabiticaGuild + groupId + '">' + groupId + '</a> &nbsp;&nbsp;Gems: ' + displayGemAmount + ')';
		}
			
		$('#headerGroupExtras').html('<div id="groupNameDisplay">' +
				displayName + 
				'</div>' +
				'<div id="groupHeaderDetailDisplay">' +
				displayGroupType + ' - ' + ' Leader: ' + displayLeaderName +
				'</div>'  
		);
	}
	
	//////////////////////////////////////////////////////////////////////
    ////   Formatting Functions used throughout  			  ////////////
    //////////////////////////////////////////////////////////////////////	
	
	function myDateConverter(date, style) { 

		var dateStr = '';
					
		if (style === 'pretty') {
			dateStr = moment(date).format('Do MMM YYYY, H:mm:ss');
		} else if (style === 'short') {
			if (date == neverDate) {
				dateStr = '-N/A-'
			} else {
				dateStr = moment(date).format('YYYY-MM-DD H:mm:ss');
			}
		} else if (style === 'long') {
			dateStr = moment(date).format('ddd Do MMMM YYYY, h:mm:ss a');
		} else if (style === 'utcTime') {
			dateStr = moment(date).utc().toISOString();
		} else if (style === 'relativeTime') {
			if (date == neverDate) {
				dateStr = '-N/A-'
			} else {
				dateStr = moment(date).fromNow();
			}
		}	else {
			var dateStr = moment(date).format(style);
		}
		return dateStr;
	}

	function renderFormattedText(text, options) {
		var md = window.habiticaMarkdown;
		if (text != undefined) {
			if (exportFormats[exportFormat].convertMarkup) text = md.render(text);
			if (exportFormats[exportFormat].removeHtml) text = $(text).text();
			if (exportFormats[exportFormat].convertLineBreaks) text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');
			if (options && options.removeParaTags) {
				text = String(text).replace(/^<p>|<\/p>\n$/g, '');
			}
			else if (options && options.setParaClass) {
				text = String(text).replace(/<p>/g,
						   '<p class="' + options.setParaClass + '">');
			}
		}
		return text;
	}
	
	function toTitleCase(str)
	{
		return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
	}
	
	function constructTable(passPar) {
		//Called in Main to display table(s).
		//Will need to be added to add buttons and row selection on the fly.
		var formattedTableHeader = [];
		var dataSetSectionId = passPar[0];
		var dataSetTable = passPar[1];
		var dataSetTableHeader = passPar[2];
		var dataSetTableSection = passPar[3];
		
		var defaultShow = []
		var defaultOrderBy = []
		var buttonCollectionColumnOption = []
		var selectValue = false
		var showButtons = []
		var allColumnDefs = []
		
		var showOptions = []
		var hideOptions = []
		
		if (debug) console.log('debug constructTable ' + dataSetSectionId);		
		
		if ($('#'+ dataSetTableSection)[0].rows.length != 0){
			if (debug) console.log ('Table exists')

			var table = $('#'+ dataSetTableSection).DataTable();

			table.clear();
			table.draw();
				
			table.rows.add(dataSetTable);
			table.draw()
		} else {
			if (debug) console.log ('Table does not exists')
			//create column header
			$.each(dataSetTableHeader, function(index, obj){
				formattedTableHeader.push({'title': obj, 'classname': dataSetTableSection + '_' + obj.replace(/ /g, ''),  'defaultContent': ''})
			});
			
			if (debugShowObject) console.log(formattedTableHeader);
			
			
			showButtons = formatShowButton()
			
			if (debugShowObject) console.log(showButtons);

			allColumnDefs = [
				{ targets: defaultShow, visible: true},
				{ targets: '_all', visible: false }
			]
			allColumnDefs = allColumnDefs.concat(sectionTables[dataSetSectionId].extraColumnDefs)
			
			if (debugShowObject) console.log(allColumnDefs);

			
			sectionTables[dataSetSectionId].events = $('#events');
			$(document).ready(function() {
				sectionTables[dataSetSectionId].table = $('#'+ dataSetTableSection).DataTable( {
					data: dataSetTable,
					columns: formattedTableHeader,
					columnDefs: allColumnDefs,
					order: defaultOrderBy,
					lengthMenu: [ [10, 25, 50, 100, 200, 500, -1], [10, 25, 50, 100, 200, 500, "All"] ],
					select: selectValue, 
					dom: 'Bfrtip',
					buttons: showButtons
					
				} );
			} );
		}
		
		//This is hard coded at the moment... need a better way
		if (sectionTables[dataSetSectionId].dynamicButtons === true) {
			var table = $('#'+ dataSetTableSection).DataTable();

			if ((group.quest.key == undefined) || (group.quest.active == true)) {
				table.button( 'questAcceptButton:name' ).nodes().hide();
				table.button( 'questRejectButton:name' ).nodes().hide();
				table.button( 'questStartButton:name' ).nodes().hide();
				if (((userId == group.leader.id) || (userIsAdmin) || (group.quest.leader  == userId)) && (group.quest.active == true) && (members[userId].quest.inQuest == "Accepted")){
					table.button( 'questAbortButton:name' ).nodes().show();
				} else {
					table.button( 'questAbortButton:name' ).nodes().hide();
				}
				if ((group.quest.leader  != userId) && (group.quest.active == true) && (members[userId].quest.inQuest == "Accepted")) {
					table.button( 'questLeaveButton:name' ).nodes().show();
				} else {
					table.button( 'questLeaveButton:name' ).nodes().hide();
				}
			} else {
				table.button( 'questAcceptButton:name' ).nodes().show();
				table.button( 'questRejectButton:name' ).nodes().show();
				if ((userId == group.leader.id) || (userIsAdmin) || (group.quest.leader  == userId) ) { 
					table.button( 'questStartButton:name' ).nodes().show();
				} else {
					table.button( 'questStartButton:name' ).nodes().hide();
				}
				table.button( 'questAbortButton:name' ).nodes().hide();
				table.button( 'questLeaveButton:name' ).nodes().hide();
			}
		}
		
		function formatShowButton() {
			var returnButtons = []
		
		
			//create export options
			$.each(exportOptions, function(index, obj){
				
				//Work out the hidden column list
				showOptions[obj.id] = eval('sectionTables[dataSetSectionId].' + obj.id + '.show')
				hideOptions[obj.id] = [];
				
				if (showOptions[obj.id][0] == 'all'){
					showOptions[obj.id] = []; // clear array
					for (i = 0; i < sectionTables[dataSetSectionId].dataTable.length; i++) { 
						showOptions[obj.id].push(i)
					}
					
				} else {
					for (i = 0; i < sectionTables[dataSetSectionId].dataTable.length; i++) { 
						if (showOptions[obj.id].indexOf(i) == -1) hideOptions[obj.id].push(i)
					}
				}
				buttonCollectionColumnOption.push({
									extend: 'colvisGroup',
									text: obj.shortDesc,
									show: showOptions[obj.id],
									hide: hideOptions[obj.id],
									className: 'columnGroupButton'
								})					
			});
			buttonCollectionColumnOption.push('columnsToggle')
			defaultShow = showOptions[exportOption]
			defaultOrderBy = eval('sectionTables[dataSetSectionId].' + exportOption + '.orderBy')
			
			if (debugShowObject) console.log(showOptions);		
			if (debugShowObject) console.log(hideOptions);	
		
			returnButtons = [
				 'pageLength', 
				 {
					extend: 'collection',
					text: 'Show/Hide',
					buttons: buttonCollectionColumnOption
				},
				{
					text: exportFormats[0].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat = exportFormats[0].id;
						parseData();
					}
				},
				{
					text: exportFormats[1].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat =  exportFormats[1].id;
						parseData();
					}
				},
				{
					text: exportFormats[2].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat =  exportFormats[2].id;
						parseData();
						}
				},
				{
					extend: 'collection',
					text: 'Print/Copy/Export',
					buttons: [ 
						 {
							extend: 'print',
							exportOptions: {
								columns: ':visible'
							}
						}, {
							extend: 'copy',
							exportOptions: {
								columns: ':visible'
							}
						}, {
							extend: 'pdf',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}, {
							extend: 'excel',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}, {
							extend: 'csv',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}						
					],
					autoClose: true
				}
			]

			//Leadership buttons
			if ((sectionTables[dataSetSectionId].leadershipButton) && ((userId == group.leader.id) || (userIsAdmin)) && (sectionTables[dataSetSectionId].reproduction == undefined)){
				var leadershipButton = [
					{
						text: 'Change Leader',
						action: function ( e, dt, node, config ) {
							var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
							var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
							var nameIndex = sectionTables[dataSetSectionId].nameIndex;
							postChangeLeader(rowData, uuidIndex, nameIndex)	
						},
						className: 'changeLeaderButton'		
					},
					{
						text: 'Remove User',
						action: function ( e, dt, node, config ) {
							var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
							var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
							var nameIndex = sectionTables[dataSetSectionId].nameIndex;
							postRemoveUser(rowData, uuidIndex, nameIndex)	
						},
						className: 'removeUserButton'
					},
					{
						text: 'Message User',
						action: function ( e, dt, node, config ) {
							var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
							var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
							var nameIndex = sectionTables[dataSetSectionId].nameIndex;
							postMessageUser(rowData, uuidIndex, nameIndex)	
						},
						className: 'messageUserButton'
					}
				]
				returnButtons = returnButtons.concat(leadershipButton)
				selectValue = true
			}
			
			if (sectionTables[dataSetSectionId].extraButton != undefined) {
				var extraButton = sectionTables[dataSetSectionId].extraButton();
				returnButtons = returnButtons.concat(extraButton)
				selectValue = true
			}

			//Chat 
			if (sectionTables[dataSetSectionId].chatButton) {
				var chatButton = {
					text: 'Post Chat',
					action: function ( e, dt, node, config ) {
							postChat()	
					},
					className: 'postChatButton'
				}
				
				returnButtons = returnButtons.concat(chatButton)
			}
			
			return returnButtons
		}


	}
	
	
	
	
	
	
	
	
	
	
	//////////////////////////////////////////////////////////////////////
    ////   Math Functions  					 ////////////
    //////////////////////////////////////////////////////////////////////
	function mean(numbers) {
	////   by Paul_Wilkins  					 ////////////
	// mean of [3, 5, 4, 4, 1, 1, 2, 3] is 2.875
		var total = 0,
			i;
		for (i = 0; i < numbers.length; i += 1) {
			total += numbers[i];
		}
		return total / numbers.length;
	}
	function median(numbers) {
	////   based on code by Paul_Wilkins  					 ////////////
		// median of [3, 5, 4, 4, 1, 1, 2, 3] = 3
		var median = 0,
			numsLen = numbers.length;
		numbers.sort(function(a, b){return a - b});
		if (numsLen % 2 === 0) { // is even
			// average of two middle numbers
			median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
		} else { // is odd
			// middle number only
			median = numbers[(numsLen - 1) / 2];
		}
		return median;
	}
	function mode(numbers) {
	////   by Daniel http://danielpike.me.uk/finding-mode-element-in-an-array/ 					 ////////////

	    var mode = {};
		var max = 0, count = 0;

		numbers.forEach(function(e) {
			if (mode[e]) { mode[e]++; }
			else { mode[e] = 1; } 

			if (count<mode[e]) { 
				max = e;
				count = mode[e];
			}
		});
		
		return max;
	}
	
	function range(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (String(numbers[0]) + ' to ' + String(numbers[numbers.length - 1]))
	}
	
	function smallest(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (numbers[0])
	}
	
	function largest(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (numbers[numbers.length - 1])
	}
	function factorial(number) {
	    var result=1;
		for (var i = 2; i <= number; i++)
			result = result * i;
		return result;
	}
	
	
	//////////////////////////////////////////////////////////////////////
    ////   Collate and Display Data  					 ////////////
    //////////////////////////////////////////////////////////////////////
	function collateAndDisplayData() {
	
	
		//format collate Data -- one function
		formatAllDataAndCollate();
		
		//run functions to create for TOC / MAIN 
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type == 'sectionTable') {
				if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') == true && groupId == 'party') || (obj.showOnly.includes('leader') == true && ((userId == group.leader.id) || (userIsAdmin)))) {
					formatTableSection(obj.id, obj.title)
				}
			} else if (obj.type == 'sectionCustom') {
				var fn = obj.functionCreate
				eval(fn + '("' + obj.id + '", "' + obj.title + '")')
			}
			
		});
		
		
		
	//////////////////////////////////////////////////////////////////////
    ////   Prep data before using                            ////////////
	//
	//     This is where you modify data to be used throughout
	//     All data is modified here
    //////////////////////////////////////////////////////////////////////
		
		function formatAllDataAndCollate() {
			transformItems = {};
			cardItems = {};
			quests = {};
			completedStats = {by: '', pending: 0, outstanding: 0, percentage: 0, time: '', overdue: ''};
			
			var arrayToAdd = []; //Used to create final array to add to dataSet
			var tempMembersList = []; //For looping through each members and adding missing variables
			var tempQuestsList = []; //For looping through each quests and adding missing variables
			var questRewardItem = {}; //For collating
			var chatLikes = [];
			
			//To complete chat stats
			var lastEphochTime = 0
			var lastEphochTime_system = 0			
			var lastEphochTime_notSystem = 0		
			
			
			//arrays to construct stuff because I like altering things in one place than trailing through code... (Didn't do too well with this section).	
			var transformArrayToConstruct = ['seafoam', 'shinySeed', 'snowball', 'spookySparkles']
			var transformItemToConstruct = [
				{id: 'id', struct: 'stringValue', value: '"~id~"', calcOnly: 'party'},
				{id: 'name', struct: 'content', value: 'content.special.~id~.text', calcOnly: 'party'},
				{id: 'description', struct: 'content', value: 'content.special.~id~.notes', calcOnly: 'party'},
				{id: 'imgTag', struct: 'stringValue', value: '"<img src=" + DOUBLEQUOTES + imageURL + imageShopPrefix + "~id~" + imageFileSuffix  + DOUBLEQUOTES + " alt=" + DOUBLEQUOTES + content.special.~id~.text + DOUBLEQUOTES + ">"', calcOnly: 'party'},
				{id: 'userAmount', struct: 'user', value: 'user.items.special.~id~', calcOnly: 'party'}
			]
			
			var cardArrayToConstruct = ['birthday', 'congrats', 'getwell', 'goodluck', 'greeting', 'thankyou'] // Other options  'valentine', 'nye' have to test if available manually.
			var utcNowArray = moment().utc().toArray() 
			if ((utcNowArray[1] == 11 && utcNowArray[2] >= 30) || (utcNowArray[1] == 0 && utcNowArray[2] < 3)) cardArrayToConstruct.push('nye')
			if (utcNowArray[1] == 1 && utcNowArray[2] >= 11 && utcNowArray[2] < 18) cardArrayToConstruct.push('valentine')
			
			var cardItemToConstruct = [
				{id: 'id', struct: 'stringValue', value: '"~id~"', calcOnly: 'party'},
				{id: 'name', struct: 'content', value: 'content.special.~id~.text', calcOnly: 'party'},
				{id: 'description', struct: 'content', value: 'content.special.~id~.notes', calcOnly: 'party'},
				{id: 'imgTag', struct: 'stringValue', value: '"<img src=" + DOUBLEQUOTES + imageURL + imageShopPrefix + "~id~" + imageFileSuffix  + DOUBLEQUOTES + " alt=" + DOUBLEQUOTES + content.special.~id~.text + DOUBLEQUOTES + ">"', calcOnly: 'party'},
				{id: 'cost', struct: 'user', value: 'content.special.~id~.value', calcOnly: 'party'}
			]
			
			var attributeArrayToConstruct = ['str', 'int', 'per', 'con']
			
			var gearArrayToConstruct = ['armor', 'back', 'body', 'eyewear', 'head', 'headAccessory', 'shield', 'weapon']
			
			///////////////////////////////////////////////////////////////
			////   Single   Data                              ////////////
			//////////////////////////////////////////////////////////////
			if (debug) console.log('debug formatAllDataAndCollate Single Data Variables');
			
			
			//User
			user.profile.nameNotPretty = user.profile.name
			user.profile.namePretty = renderFormattedText(user.profile.name)
			if (user.auth != undefined && user.auth.local != undefined && user.auth.local.username != undefined) {
				user.profile.username = user.auth.local.username 
			} else {
				user.profile.username = noUsernamePrefix + user.profile.name
			}
			
			//Group
			group.nameNotPretty = group.name //render later without html tags?
			group.namePretty = renderFormattedText(group.name)
			
			group.leader.profile.nameNotPretty = group.leader.profile.name //render later without html tags?
			group.leader.profile.namePretty = renderFormattedText(group.leader.profile.name)
			if (group.leader.auth != undefined && group.leader.auth.local != undefined && group.leader.auth.local.username != undefined) {
				group.leader.profile.username = group.leader.auth.local.username 
				group.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + group.leader.id + '" target="_blank">' + group.leader.auth.local.username + '</a>'
			} else {
				group.leader.profile.username = noUsernamePrefix + group.leader.profile.name 
				group.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + group.leader.id + '" target="_blank">' + noUsernamePrefix + group.leader.profile.name + '</a>'
			}		
			group.leader.profile.usernamePretty = group.leader.profile.usernameNotPretty
			
			group.memberTotals = {}
			group.memberTotals.fetchCount = 0 //to populate later
			group.memberTotals.inInn = 0 //to populate later
			group.memberTotals.activeLess12Hr = 0 //to populate later
			group.memberTotals.activeLess24Hr = 0 //to populate later
			group.memberTotals.activeLessWeek = 0 //to populate later
			group.memberTotals.activeLessMonth = 0 //to populate later
			if (groupId == 'party')	group.quest.memberCount = 0 //to populate later
			group.memberTotals.inInn_activeLess12Hr = 0 //to populate later
			group.memberTotals.inInn_activeLess24Hr = 0 //to populate later
			group.memberTotals.inInn_activeLessWeek = 0 //to populate later
			group.memberTotals.inInn_activeLessMonth = 0 //to populate later
			if (groupId == 'party')	{
				group.quest.inInn_memberCount = 0 //to populate later
				group.quest.damageTotal = 0 //to populate later
				group.quest.damageTotalCurrent = 0 //to populate later
				group.quest.damageTotalPrevious = 0 //to populate later
				group.quest.damageBoss = 0 //to populate later
				group.quest.damageBossCurrent = 0 //to populate later
				group.quest.damageBossPrevious = 0 //to populate later
				group.quest.collectionTotalCurrent = 0 //to populate later
				group.quest.collectionTotalPrevious = 0 //to populate later
				if (group.quest.active) {
					 noQuestsInChat = 0
				} else {
					noQuestsInChat = -1
				}
			}
			group.memberTotals.class = {}
			group.memberTotals.class.warrior = 0 //to populate later
			group.memberTotals.class.wizard = 0 //to populate later
			group.memberTotals.class.rogue = 0 //to populate later
			group.memberTotals.class.healer = 0 //to populate later
			group.memberTotals.underLevel10 = 0 //to populate later
			group.chatTotals = {}
			group.chatTotals.count_notSystem = 0 //to populate later
			group.chatTotals.count_system = 0 //to populate later
			group.chatTotals.timePeriod = []
			group.chatTotals.timePeriod_notSystem = []
			group.chatTotals.timePeriod_system = []
			group.chatTotals.firstChat  = reformatDate(neverDate)
			group.chatTotals.lastChat  = reformatDate(neverDate)

			
			
			if (groupId == 'party') {
				//Transform Items - Setup
				if (debug) console.log('debug formatAllDataAndCollate Transform Items Array Setup');

				$.each(transformArrayToConstruct, function(index, obj){
					transformItems[obj] = {}
					$.each(transformItemToConstruct, function(index2, obj2){
							var stringToEval = obj2.value.replace(/~id~/g, obj)
							transformItems[obj][obj2.id] = eval(stringToEval); 
					});
				});
				if (debugShowObject) console.log(transformItems)
			
				//Card Items - Setup
				if (debug) console.log('debug formatAllDataAndCollate Card Items Array Setup');
			
				$.each(cardArrayToConstruct, function(index, obj){
					cardItems[obj] = {}
					$.each(cardItemToConstruct, function(index2, obj2){
							var stringToEval = obj2.value.replace(/~id~/g, obj)
							cardItems[obj][obj2.id] = eval(stringToEval); 
					});
				});
				if (debugShowObject) console.log(cardItems)
			
				//setup will loop later for section tables
				if (debug) console.log('debug formatAllDataAndCollate Quest Items Array Setup');
				quests = content.quests
			
				$.each(quests, function(index, obj){
					quests[obj.key].imgTag = '<img src="' + imageURL + imageQuestPrefix + obj.key + imageFileSuffix + '" alt="' + obj.text + '">'
					quests[obj.key].imgTagQuestScroll = '<img src="' + imageURL + imageQuestScrollPrefix + obj.key + imageFileSuffix + '" alt="' + obj.text + '">'
					quests[obj.key].id = quests[obj.key].key //This is so I can just copy code without worrying
					quests[obj.key].ownScroll = 0
					quests[obj.key].memberCompleted = {};
					quests[obj.key].memberCompleted.memberCount = 0
					quests[obj.key].memberCompleted.only1 = 0
					quests[obj.key].memberCompleted.only2 = 0
					quests[obj.key].memberCompleted.only3 = 0
					quests[obj.key].memberCompleted.only4 = 0
					quests[obj.key].memberCompleted.only5 = 0
					quests[obj.key].memberCompleted.only6 = 0
					quests[obj.key].memberCompleted.only7OrMore = 0
					quests[obj.key].memberCompleted.only6OrMore = 0 //For Magic Hatching Potion Quests
					
					
					if (quests[obj.key].boss != undefined){
						quests[obj.key].typeOf = 'boss'
						quests[obj.key].defeatBy = quests[obj.key].boss.hp + 'hp' 
						if (quests[obj.key].boss.rage != undefined) quests[obj.key].defeatBy += ' + rage'
					} else {
						quests[obj.key].typeOf = 'collection' //assumption but what the hey!
						quests[obj.key].defeatBy = ''
						$.each(quests[obj.key].collect, function(index2, obj2){
							quests[obj.key].defeatBy += obj2.count + ' ' + obj2.text + ' ' 
						});
					}
					
					//Put rewards as a single string
					questRewardItem = {}; //Clear array
					var rewardItemString = ''
					if (quests[obj.key].drop.items != undefined) {
						$.each(quests[obj.key].drop.items, function(index2, obj2){
								if (questRewardItem[obj2.key] == undefined) {
									questRewardItem[obj2.key] = obj2
									questRewardItem[obj2.key].total = 1
									
									if (
										((quests[obj.key].category=='pet') || (quests[obj.key].category=='timeTravelers') )&& 
										(obj2.type=='eggs')
									){
										quests[obj.key].pet = content.questEggs[obj2.key]
									}
									
									if (quests[obj.key].category=='hatchingPotion' && obj2.type=='hatchingPotions'){
										quests[obj.key].magicPotion = content.hatchingPotions[obj2.key]
									}
								} else {
									questRewardItem[obj2.key].total++
								}
						});
						
						
						$.each(questRewardItem, function(index2, obj2){
							if (rewardItemString != '') rewardItemString += ', '
							rewardItemString += obj2.total + ' x ' + obj2.text 
						});
						
					
					}
					quests[obj.key].drop.rewardItemString = rewardItemString
					
					if (quests[obj.key].pet == undefined) {
						quests[obj.key].pet = {}
					}
					
					if (quests[obj.key].magicPotion == undefined) {
						quests[obj.key].magicPotion = {}
					}
					
					if (quests[obj.key].category != 'world'){ //Don't include world quests
						tempQuestsList.push(quests[obj.key])
					}
				});
				if (debugShowObject) console.log(quests)
			};
			
			
			// Loop through all members to add all items to be populated (avoid messy undefines later)
			$.each(memberListToFetch, function(index, obj){
					members[obj.id].lastChat = {}
					members[obj.id].lastChat.text = ''
					members[obj.id].lastChat.textPretty = ''
					members[obj.id].lastChat.occured = reformatDate(neverDate)
					members[obj.id].lastChat.countTotal = 0
					members[obj.id].lastChat.countLess12Hr = 0
					members[obj.id].lastChat.countLess24Hr = 0
										
					members[obj.id].lastBuff = {}
					members[obj.id].lastBuff.occured = reformatDate(neverDate)
					members[obj.id].lastBuff.countTotal = 0
					members[obj.id].lastBuff.countLess12Hr = 0
					members[obj.id].lastBuff.countLess24Hr = 0

					members[obj.id].lastTransformation = {}
					members[obj.id].lastTransformation.occured = reformatDate(neverDate)
					members[obj.id].lastTransformation.countTotal = 0
					members[obj.id].lastTransformation.countLess12Hr = 0
					members[obj.id].lastTransformation.countLess24Hr = 0

					members[obj.id].quest = {}
					members[obj.id].quest.damageTotal = 0
					members[obj.id].quest.damageTotalCurrent = 0
					members[obj.id].quest.damageTotalPrevious = 0
					members[obj.id].quest.damageBoss = 0
					members[obj.id].quest.damageBossCurrent = 0
					members[obj.id].quest.damageBossPrevious = 0
					members[obj.id].quest.collectionTotal = 0
					members[obj.id].quest.collectionTotalCurrent = 0
					members[obj.id].quest.collectionTotalPrevious = 0
					
					members[obj.id].quest.pending = ''
					members[obj.id].quest.reqFinish = ''
			});
			
			
			
			///////////////////////////////////////////////////////////////
			////   Process Sections / Table / Count Values     ////////////
			//////////////////////////////////////////////////////////////
			if (debug) console.log('debug formatAllDataAndCollate Secion/tableData');
			
			//Clear arrays
			$.each(sectionsToDisplay, function(index, obj){
				if (obj.type == 'sectionTable'){
					sectionTables[obj.id].dataSet=[];
				}
			});
			if (debugShowObject) console.log(sectionTables);	
			
			
			///////////////////////////////////////////////////////////////
			////   Chat Section                                ////////////
			//////////////////////////////////////////////////////////////
			$.each(group.chat, function(index, obj){
				
				modifyChatProperties(obj);
								
				//Add in participation dates
				//assuming travelling from last to earliest
				if (members[obj.uuid]  !=  undefined) {
					members[obj.uuid].lastChat.countTotal++
					if (moment().subtract(12, 'hours').isBefore(obj.creation.utcTime)) members[obj.uuid].lastChat.countLess12Hr++
					if (moment().subtract(24, 'hours').isBefore(obj.creation.utcTime)) members[obj.uuid].lastChat.countLess24Hr++
					
					if (members[obj.uuid].lastChat.occured.utcTime < obj.creation.utcTime) {
						members[obj.uuid].lastChat.text = obj.text
						members[obj.uuid].lastChat.textPretty = obj.textPretty
						members[obj.uuid].lastChat.occured = obj.creation
					} 
				}
				
				//Chat Likes
				obj.likeCount = {}
				obj.likeCount.total = 0
				obj.likeCount.totalInGroup = 0
				
				$.each(obj.likes, function(index2, obj2){
					if (obj2) {
						obj.likeCount.total++
						if (members[index2] != undefined){
							obj.likeCount.totalInGroup++
						} 
						addToArray = {};
						addToArray = {member: members[index2], chat: obj, id: index2}
						chatLikes.push(addToArray)
					}
				});
				
				
				
				//Quests/Buffs/Transformations
				if (groupId == 'party') {
					if (obj.uuid == 'system' && (obj.info != undefined)) {
					
						if (obj.info.type === 'all_items_found' || obj.info.type == 'boss_defeated' ) {
							 noQuestsInChat += 1
						} else if (obj.info.user != undefined) {						
							$.each(memberListToFetch, function(index2, obj2){						
								if (members[obj2.id].profile.name == obj.info.user) 
								{
									objZ = members[obj2.id]
							
									switch (obj.info.type) {
									case 'spell_cast_party' :
										//Buff
										if (objZ.lastBuff.occured.utcTime < obj.creation.utcTime) objZ.lastBuff.occured = obj.creation
										objZ.lastBuff.countTotal++
										
										if (moment().subtract(12, 'hours').isBefore(obj.creation.utcTime)) objZ.lastBuff.countLess12Hr++
										if (moment().subtract(24, 'hours').isBefore(obj.creation.utcTime)) objZ.lastBuff.countLess24Hr++
										break;
									case 'spell_cast_user' :
										//Transformation
										if (objZ.lastTransformation.occured.utcTime < obj.creation.utcTime) objZ.lastTransformation.occured = obj.creation
										objZ.lastTransformation.countTotal++
										
										if (moment().subtract(12, 'hours').isBefore(obj.creation.utcTime)) objZ.lastTransformation.countLess12Hr++
										if (moment().subtract(24, 'hours').isBefore(obj.creation.utcTime)) objZ.lastTransformation.countLess24Hr++
										break;
									case 'boss_damage' :				
										//attacks	
										var damageInflicted = Number(obj.info.userDamage)
										var damageBoss = Number(obj.info.bossDamage)								
										
										objZ.quest.damageTotal += damageInflicted
										objZ.quest.damageBoss += damageBoss
										group.quest.damageTotal += damageInflicted
										group.quest.damageBoss += damageBoss
										
										if (noQuestsInChat == 0) {
											objZ.quest.damageTotalCurrent += damageInflicted
											objZ.quest.damageBossCurrent += damageBoss
											group.quest.damageTotalCurrent += damageInflicted
											group.quest.damageBossCurrent += damageBoss
										}
										
										if (noQuestsInChat == 1) {
											objZ.quest.damageTotalPrevious += damageInflicted
											objZ.quest.damageBossPrevious += damageBoss
											group.quest.damageTotalPrevious += damageInflicted
											group.quest.damageBossPrevious += damageBoss
										}									
										break;
									case 'user_found_items' :
										//collection quest
										var tempCollection = 0
										
										$.each(obj.info.items, function(key, value){
											tempCollection += Number(value)
										})
																		
										objZ.quest.collectionTotal += tempCollection
										group.quest.collectionTotal += tempCollection
										
										if (noQuestsInChat == 0) {
											group.quest.collectionTotalCurrent += tempCollection
											objZ.quest.collectionTotalCurrent += tempCollection
										}
										
										if (noQuestsInChat == 1) {
											group.quest.collectionTotalPrevious += tempCollection
											objZ.quest.collectionTotalPrevious += tempCollection
										}
										break;
									}
									return false;
								}
							});
						}
					}
				}
				
				//Date Times, counts etc
				if (lastEphochTime != 0) group.chatTotals.timePeriod.push(lastEphochTime-obj.timestamp);
				lastEphochTime = obj.timestamp
				
				if (obj.uuid != 'system') 
				{	
					group.chatTotals.count_notSystem++
					
					if (lastEphochTime_notSystem != 0) group.chatTotals.timePeriod_notSystem.push(lastEphochTime_notSystem-obj.timestamp);
					lastEphochTime_notSystem = obj.timestamp

				} else {
					group.chatTotals.count_system++
					
					if (lastEphochTime_system != 0) group.chatTotals.timePeriod_system.push(lastEphochTime_system-obj.timestamp);
					lastEphochTime_system = obj.timestamp
				}
				
				if (group.chatTotals.firstChat.utcTime != myDateConverter(neverDate, 'utcTime')){
					if (moment(obj.creation.utcTime).isBefore(group.chatTotals.firstChat.utcTime)) group.chatTotals.firstChat = obj.creation
				} else {
					group.chatTotals.firstChat = obj.creation
				}
				if (group.chatTotals.lastChat.utcTime != myDateConverter(neverDate, 'utcTime')){
					if (moment(obj.creation.utcTime).isAfter(group.chatTotals.lastChat.utcTime)) group.chatTotals.lastChat = obj.creation
				} else {
					group.chatTotals.lastChat = obj.creation
				}
				
				
				
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'chat'){
							arrayToAdd = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								arrayToAdd.push(eval('obj.' + obj3))
							});
							//Don't include system messages if chatNotSystemExport
							if ((obj.uuid != 'system' && obj2.id == 'chatNotSystemExport') || (obj.uuid == 'system' && obj2.id == 'chatSystemExport') || (obj2.id != 'chatNotSystemExport' && obj2.id != 'chatSystemExport')) sectionTables[obj2.id].dataSet.push(arrayToAdd); 
						}
						
					}
				});
			}); 
			if (debug) console.log('Finish collating chatExportSet');
			group.chatTotals.chatDayPeriod = (Math.round((moment(group.chatTotals.lastChat.utcTime).diff(moment(group.chatTotals.firstChat.utcTime), 'hours'))/24*100)/100) 

			

			
			
			///////////////////////////////////////////////////////////////
			////   Member First Process  (not add)           ////////////
			//////////////////////////////////////////////////////////////
			//Create simple array to pop from (not a named Array)
			$.each(memberListToFetch, function(index, obj){
				modifyUserProperties(members[obj.id]);
			
				group.memberTotals.fetchCount++
			
			
				//Fix Rounding issues with Members
				members[obj.id].quest.damageTotal =  Math.round(Number(members[obj.id].quest.damageTotal)* 10000) / 10000
				members[obj.id].quest.damageTotalCurrent =  Math.round(Number(members[obj.id].quest.damageTotalCurrent)* 10000) / 10000
				members[obj.id].quest.damageTotalPrevious =  Math.round(Number(members[obj.id].quest.damageTotalPrevious)* 10000) / 10000
				members[obj.id].quest.damageBoss =  Math.round(Number(members[obj.id].quest.damageBoss)* 10000) / 10000
				members[obj.id].quest.damageBossCurrent =  Math.round(Number(members[obj.id].quest.damageBossCurrent)* 10000) / 10000
				members[obj.id].quest.damageBossPrevious =  Math.round(Number(members[obj.id].quest.damageBossPrevious)* 10000) / 10000
				
				if (quests[group.quest.key] != undefined) {
					if ((group.quest.members[obj.id] == true) || !(group.quest.active) ) {
						if (quests[group.quest.key].boss) {
							members[obj.id].quest.pending = Math.floor(members[obj.id].party.quest.progress.up * 10) / 10
						} else if (quests[group.quest.key].collect) {
							members[obj.id].quest.pending = members[obj.id].party.quest.progress.collectedItems
						} else {
							members[obj.id].quest.pending = Math.floor(members[obj.id].party.quest.progress.up * 10) / 10 + ' dmg or '  + members[obj.id].party.quest.progress.collectedItems + ' collected items'
						}
					} else {
						members[obj.id].quest.pending = 0 //Not part of the active quest
					}
				}
			
				//Attribute Calculates
				members[obj.id].attributeTotals = {}
				$.each(attributeArrayToConstruct, function (index2, obj2){
					members[obj.id].attributeTotals[obj2] = {};
					if (members[obj.id].stats.lvl < 100) {
						members[obj.id].attributeTotals[obj2].lvl = Math.floor(members[obj.id].stats.lvl / 2)
					} else {
						members[obj.id].attributeTotals[obj2].lvl = Math.floor(100 / 2)
					};
					members[obj.id].attributeTotals[obj2].buff = members[obj.id].stats.buffs[obj2]
					members[obj.id].attributeTotals[obj2].allocated = members[obj.id].stats[obj2]
					members[obj.id].attributeTotals[obj2].gear = 0
					members[obj.id].attributeTotals[obj2].gearBuff = 0
					$.each(gearArrayToConstruct, function (index3, obj3){
						if (members[obj.id].items.gear.equipped[obj3] != undefined) {
							var gearKey = members[obj.id].items.gear.equipped[obj3]
							if (content.gear.flat[gearKey] != undefined) {
								members[obj.id].attributeTotals[obj2].gear += content.gear.flat[gearKey][obj2]
								if (content.gear.flat[gearKey].klass == members[obj.id].stats.class || content.gear.flat[gearKey].specialClass == members[obj.id].stats.class ) members[obj.id].attributeTotals[obj2].gearBuff += content.gear.flat[gearKey][obj2] / 2
							}
						}
					});
					members[obj.id].attributeTotals[obj2].total = members[obj.id].attributeTotals[obj2].lvl + members[obj.id].attributeTotals[obj2].buff + members[obj.id].attributeTotals[obj2].allocated + members[obj.id].attributeTotals[obj2].gear + members[obj.id].attributeTotals[obj2].gearBuff
				});
				

				//Determine Activity
				if (groupId == 'party' && (members[obj.id].lastChat.occured.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastDropItem.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastBuff.occured.utcTime < members[obj.id].lastTransformation.occured.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastTransformation.occured
				} else if (groupId == 'party' && (members[obj.id].lastChat.occured.utcTime < members[obj.id].lastBuff.occured.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastBuff.occured.utcTime) && (members[obj.id].lastDropItem.utcTime < members[obj.id].lastBuff.occured.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastBuff.occured
				} else if ((members[obj.id].lastChat.occured.utcTime < members[obj.id].lastDropItem.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastDropItem.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastDropItem
				} else if (members[obj.id].lastChat.occured.utcTime < members[obj.id].lastLoggedIn.utcTime){
					members[obj.id].lastActive = members[obj.id].lastLoggedIn
				} else {
					members[obj.id].lastActive = members[obj.id].lastChat.occured
					}
				
				if (moment().subtract(12, 'hours').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.activeLess12Hr++
				if (moment().subtract(24, 'hours').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.activeLess24Hr++
				if (moment().subtract(7, 'days').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.activeLessWeek++
				if (moment().subtract(1, 'months').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.activeLessMonth++
				
				if (members[obj.id].preferences.sleep == true){
					group.memberTotals.inInn++

					if (moment().subtract(12, 'hours').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.inInn_activeLess12Hr++
					if (moment().subtract(24, 'hours').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.inInn_activeLess24Hr++
					if (moment().subtract(7, 'days').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.inInn_activeLessWeek++
					if (moment().subtract(1, 'months').isBefore(members[obj.id].lastActive.utcTime)) group.memberTotals.inInn_activeLessMonth++
				}

				//Class Stats
				group.memberTotals.class[members[obj.id].stats.class]++
				if (members[obj.id].stats.lvl < 11) group.memberTotals.underLevel10++
				
				
				//Party/Quest Stats
				if (groupId == 'party') {
					//Quest information
					if (group.quest.leader == obj.id) {
						members[obj.id].quest.leader=true
						group.quest.leaderProfile = {}
						group.quest.leaderProfile = members[obj.id].profile 
						group.quest.leaderProfile.lastLoggedIn = members[obj.id].lastLoggedIn
						group.quest.leaderProfile.lastActive = members[obj.id].lastActive
					} else {
						members[obj.id].quest.leader = false
					}
					if (group.quest.members[obj.id] == true) {
						members[obj.id].quest.inQuest = 'Accepted'
						group.quest.memberCount++
					} else if ((group.quest.members[obj.id] == false) || (group.quest.active == true)) {
						members[obj.id].quest.inQuest = 'Rejected'
					} else {
						members[obj.id].quest.inQuest = 'Pending'
					}
					
					
					//Collate Quest Stats
					$.each(quests, function(index2, obj2){
						if ((members[obj.id].items.quests[obj2.key] != undefined) && (members[obj.id].items.quests[obj2.key] > 0))quests[obj2.key].ownScroll += members[obj.id].items.quests[obj2.key]

						if (members[obj.id].achievements.quests != undefined ) {
							if (members[obj.id].achievements.quests[obj2.key] != undefined ) {
								quests[obj2.key].memberCompleted.memberCount++
								switch(members[obj.id].achievements.quests[obj2.key]) {
									case 0:
										//do nothing
										break;
									case 1:
										quests[obj2.key].memberCompleted.only1++
										break;
									case 2:
										quests[obj2.key].memberCompleted.only2++
										break;
									case 3:
										quests[obj2.key].memberCompleted.only3++
										break;
									case 4:
										quests[obj2.key].memberCompleted.only4++
										break;
									case 5:
										quests[obj2.key].memberCompleted.only5++
										break;
									case 6:
										quests[obj2.key].memberCompleted.only6++
										quests[obj2.key].memberCompleted.only6OrMore++
										break;
									default:
										quests[obj2.key].memberCompleted.only7OrMore++
										quests[obj2.key].memberCompleted.only6OrMore++										
								}
								
							}							
						}
					});
						
					//Transformational Information
					if (members[obj.id].stats.buffs.seafoam) members[obj.id].transformStatus = 'Seafoam'
					if (members[obj.id].stats.buffs.shinySeed) members[obj.id].transformStatus = 'Shiny Seed'
					if (members[obj.id].stats.buffs.snowball) members[obj.id].transformStatus = 'Snow Ball'
					if (members[obj.id].stats.buffs.spookySparkles) members[obj.id].transformStatus = 'Spooky Sparkles'
					if (members[obj.id].transformStatus == undefined) members[obj.id].transformStatus = '-none-'
				}
								
				tempMembersList.push(members[obj.id])
			}); 
			if (debugShowObject) console.log(tempMembersList);

			///////////////////////////////////////////////////////////////
			////   Determine who will finish the quest        ////////////
			//////////////////////////////////////////////////////////////
			if ((groupId == 'party') && (group.quest.key != undefined)) {
				//Sort. Clone first to avoid issues.
				var tempML = tempMembersList.slice(0)
				
				tempML.sort(function(a,b){
					  // Subtract them to get a value that is either negative, positive, or zero to sort on.
					  return new Date(a.lastLoggedIn.utcTime) - new Date(b.lastLoggedIn.utcTime);
				});
				if (debugShowObject) console.log(tempML)

				var collectType = 0 
				
				if (quests[group.quest.key].boss) {
					if (group.quest.progress.hp == undefined) 
					{
						completedStats.outstanding = quests[group.quest.key].boss.hp
					} else {
						completedStats.outstanding = Math.round(group.quest.progress.hp * 100) / 100 
					}
				} else {
					var collectTarget = 0 
					var collectDone = 0 
									
					$.each(quests[group.quest.key].collect, function(index, obj){
						collectTarget += obj.count
						if (group.quest.progress.collect[index] != undefined) {
							if (group.quest.progress.collect[index]>obj.count) {
								collectDone += obj.count 
							} else {
								collectDone += group.quest.progress.collect[index] 
							}
						}
						collectType += 1						
					});
											
					completedStats.outstanding = collectTarget - collectDone
				}
				
				//Go through each one subtracting each damage till enough.
				for (i = 0; i < tempML.length; i++) { 
					if (debug) console.log(tempML[i].profile.usernameNotPretty + '    ' + tempML[i].quest.pending)
					if ((tempML[i].preferences.sleep != true) && (moment().subtract(24, 'hours').isBefore(tempML[i].lastActive.utcTime))) {
						completedStats.pending += tempML[i].quest.pending
						members[tempML[i].id].quest.reqFinish = completedStats.outstanding - completedStats.pending
						tempML[i].quest.reqFinish = Math.ceil(members[tempML[i].id].quest.reqFinish * 100) / 100 //round down.
					} else {
						completedStats.overdue += ', ' + tempML[i].profile.usernameNotPretty
					}

					if (collectType <= 1) {
						completedStats.percentage = 100
					} else {
						/***************************************************************************************
							Formula to calculate probability. 
							
							x - Outstanding Items
							k - x-1
							n - pending items found (or number of attempts of finding item)
							s - number of collection types
							
							Probability = 1 - F(k,n,s)
							
							F(k,n,s) = SIGMA Summation of (k to 0 as j)
										n!/(j!(n-j!))  (1/s)^j  (1-1/s)^(n-j)

							Yeah this is a little complicated.
							
							Thanks to anonymous Mathematician I found in a dark room playing Stellaris.
						***************************************************************************************/
						var tempProb = 0
						
						for (var j = completedStats.outstanding - 1; j >= 0; j--) {
							tempProb += (factorial(completedStats.pending) / (factorial(j) * factorial(completedStats.pending - j))) *
										Math.pow(1/collectType, j) *
										Math.pow((1-1/collectType), (completedStats.pending - j)); 
										
						}
						
						completedStats.percentage = 1 - tempProb
						
						if (debugShowObject) console.log(collectTarget)
						if (debugShowObject) console.log(completedStats.outstanding)
						if (debugShowObject) console.log(completedStats.pending)
						if (debugShowObject) console.log(collectType)
						if (debugShowObject) console.log(completedStats.percentage)
						
						
						completedStats.percentage = Math.round(completedStats.percentage*10000)/100 
					}

					if ((completedStats.outstanding <= completedStats.pending) && (completedStats.percentage > 5)) {
						completedStats.by = tempML[i].profile.usernameNotPretty
						var tempDate = moment(tempML[i].lastLoggedIn.utcTime).add(1, 'd')
						completedStats.time = reformatDate(tempDate)
						break
					}
				}

				//if the percentage probability was so low but it was the last item 
				if ((completedStats.by == '') && (completedStats.outstanding <= completedStats.pending)) {
						completedStats.by = tempML[tempML.length - 1].profile.usernameNotPretty
						var tempDate = moment(tempML[tempML.length - 1].lastLoggedIn.utcTime).add(1, 'd')
						completedStats.time = reformatDate(tempDate)				
				}
				
				
				if (debugShowObject) console.log(completedStats)
				
				if (completedStats.overdue.length > 0) completedStats.overdue = completedStats.overdue.substring(2)
			}
			
			completedStats.pending = Math.floor(completedStats.pending * 100) / 100 //round down.
			if (debugShowObject) console.log(sectionTables);
			
			
			
			///////////////////////////////////////////////////////////////
			////  Challenge Group Data    							////////////
			//////////////////////////////////////////////////////////////
			$.each(challengeGroup, function(index, obj){
				modifyChallengeGroupProperties(obj);
				
				if (members[obj.leader.id] != undefined){
					obj.leader.lastActive = members[obj.leader.id].lastActive
				} else {
					obj.leader.lastActive = reformatDate(neverDate)
				}
				
				
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'challengeGroup'){
							arrayToAdd = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								arrayToAdd.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(arrayToAdd);
						}
					}
				});
			}); 
			if (debug) console.log('Finish collating challengeGroup');
			
			
			
			///////////////////////////////////////////////////////////////
			////   members final loop  process no calcs    ////////////
			//////////////////////////////////////////////////////////////
			$.each(tempMembersList, function(index, obj){			
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'member'){
							arrayToAdd = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								arrayToAdd.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(arrayToAdd);
						}
					}
				});
			}); 
			if (debug) console.log('Finish collating memberListSet');

			
			///////////////////////////////////////////////////////////////
			////  Quests - Final loop no calcs    ////////////
			//////////////////////////////////////////////////////////////
			if (groupId == 'party'){			
				//Quests Now
				$.each(tempQuestsList, function(index, obj){
					//add missing stat (Can't do it earlier well you try to keep these things neat) 
					quests[obj.key].memberCompleted.missingCount = group.memberTotals.fetchCount - quests[obj.key].memberCompleted.memberCount
				
					$.each(sectionsToDisplay, function(index2, obj2){
						if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
							if (sectionTables[obj2.id].type == 'quest'){
								arrayToAdd = []; //clear array
								$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
									arrayToAdd.push(eval('obj.' + obj3))
								});
								if (
									(
										(obj2.id == 'questMagicCompleted') && 
										(obj.category == 'hatchingPotion')
									) || 
									(
										(obj2.id == 'questPetCompleted') && 
										(obj.pet.text != undefined)
									) || 
									(
										(obj2.id != 'questMagicCompleted') && 
										(obj2.id != 'questPetCompleted') 
									)
								) sectionTables[obj2.id].dataSet.push(arrayToAdd); //Testing obj.pet.text != undefined as category Pet also contains the Polar Bear/Cub which gives a special pet not the eggs. 
							}
						}
					});
				}); 
				if (debug) console.log('Finish collating questData');
			}
			
			///////////////////////////////////////////////////////////////
			////   chat likes (Chat was before)				  ////////////
			//////////////////////////////////////////////////////////////
			$.each(chatLikes, function(index, obj){
				//quick fix as member function done after
				if (members[obj.id] != undefined){
					obj.name = members[obj.id].profile.name
					obj.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.namePretty + '</a>'
					obj.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.nameNotPretty + '</a>'
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.username + '</a>'
				} else {
					obj.name = notAvailableMember
					obj.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
					obj.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'chatLikes'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			});
			if (debug) console.log('Finish chat Likes');

			///////////////////////////////////////////////////////////////
			////   PMs                                      ////////////
			//////////////////////////////////////////////////////////////
			$.each(user.inbox.messages, function(index, obj){
				if (memberListToFetch_idOnly.includes(obj.uuid)){
					modifyInboxProperties(obj);			
					
					$.each(sectionsToDisplay, function(index2, obj2){
						if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
							if (sectionTables[obj2.id].type == 'inbox'){
								addToArray = []; //clear array
								$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
									addToArray.push(eval('obj.' + obj3))
								});
								//Don't include system messages if chatNotSystemExport
								sectionTables[obj2.id].dataSet.push(addToArray); 
							}
							
						}
					});
				}
			}); 
			if (debug) console.log('Finish collating PMs');
		};	
		
		//////////////////////////////////////////////////////////////////////
		////   Formatting data for data sets     ///////////////////////////
		//////////////////////////////////////////////////////////////////////
	    function modifyChatProperties(obj) {
			obj.textPretty  = renderFormattedText(obj.text);
			if (obj.uuid == 'system') {
				obj.userPretty = 'System'
				obj.userNotPretty = 'System'
				obj.username = 'System'
				obj.usernameNotPretty = 'System'
				obj.usernamePretty = 'System'
				obj.userStylesPretty = ''
			} else {
				obj.userPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user) + '</a>';
				obj.userNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user, {removeParaTags: true}) + '</a>';
				if (obj.username == undefined) {
					obj.username = noUsernamePrefix + obj.user
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + noUsernamePrefix + obj.user + '</a>';
				} else {
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + obj.username + '</a>';
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				if (obj.userStyles != undefined) {
					obj.userStylesPretty = JSON.stringify(obj.userStyles, null, ' ').replace(/: \{\n\s+/g, ': {').replace(/",\n\s+/g, ', ').replace(/"\n\s+\}/g, '}').replace(/(\r\n|\n|\r)/g,"<br />").replace(/"  "/g, '&nbsp;&nbsp');;
				} else {
					obj.userStylesPretty = ''
				}
			}

			obj.creation  = reformatDate(obj.timestamp);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
			
		}

		function modifyInboxProperties(obj) {
			obj.textPretty  = renderFormattedText(obj.text, {'setParaClass':'chatText'});
			if (obj.uuid == 'system') {
				obj.userPretty = 'System'
				obj.userNotPretty = 'System'
				obj.username = 'System'
				obj.usernameNotPretty = 'System'
				obj.usernamePretty = 'System'
				obj.userStylesPretty = ''
			} else {
				obj.userPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user) + '</a>';
				obj.userNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user, {removeParaTags: true}) + '</a>';
				if (obj.username == undefined) {
					obj.username = noUsernamePrefix + obj.user
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + noUsernamePrefix + obj.user + '</a>';
				} else {
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + obj.username + '</a>';
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				if (obj.userStyles != undefined) {
					obj.userStylesPretty = JSON.stringify(obj.userStyles, null, ' ').replace(/: \{\n\s+/g, ': {').replace(/",\n\s+/g, ', ').replace(/"\n\s+\}/g, '}').replace(/(\r\n|\n|\r)/g,"<br />").replace(/"  "/g, '&nbsp;&nbsp');;
				} else {
					obj.userStylesPretty = ''
				}
				
			}
			obj.creation  = reformatDate(obj.timestamp);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
			if (obj.sent === true) {
				obj.sentPretty = 'true'
			} else {
				obj.sentPretty = 'false'
			}
		}

	    function modifyChallengeGroupProperties(obj) {
			obj.namePretty  = renderFormattedText(obj.name);
			obj.nameNotPretty  = renderFormattedText(obj.name, {removeParaTags: true});
			obj.nameLink  = '<a href="' + serverCDT + '?' + hookCDT_uid + '=' + userId + '&' + hookCDT_challengeid + '=' + obj.id + '" target="_blank">' + renderFormattedText(obj.name, {removeParaTags: true}) + '</a>';
			obj.shortNamePretty  = renderFormattedText(obj.shortName);
			obj.shortNameNotPretty  = renderFormattedText(obj.shortName, {removeParaTags: true});
			
			obj.descriptionPretty  = renderFormattedText(obj.description);
			if (obj.leader != undefined) {
				obj.leader.profile.namePretty = '<a href="' + serverHabiticaProfile + obj.leader.id + '" target="_blank">' + renderFormattedText(obj.leader.profile.name) + '</a>'
				obj.leader.profile.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.leader.id + '" target="_blank">' + renderFormattedText(obj.leader.profile.name, {removeParaTags: true}) + '</a>'
				if (obj.leader.auth != undefined && obj.leader.auth.local != undefined && obj.leader.auth.local.username != undefined) {
					obj.leader.profile.username = obj.leader.auth.local.username
					obj.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.leader.id + '" target="_blank">' + obj.leader.auth.local.username + '</a>'
				} else
				{
					obj.leader.profile.username = noUsernamePrefix + obj.leader.profile.name
					obj.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.leader.id + '" target="_blank">' + noUsernamePrefix + obj.leader.profile.name  + '</a>'
				}
				obj.leader.profile.usernamePretty = obj.leader.profile.usernameNotPretty
			} else {
				obj.leader = {}
				obj.leader.profile = {}
				obj.leader.profile.name = notAvailableMember
				obj.leader.profile.namePretty = notAvailableMember
				obj.leader.profile.nameNotPretty = notAvailableMember
				obj.leader.profile.username = notAvailableMember
				obj.leader.profile.usernameNotPretty = notAvailableMember
				obj.leader.profile.usernamePretty = notAvailableMember
			}
			
			obj.creation  = reformatDate(obj.createdAt);
			obj.lastUpdated  = reformatDate(obj.updatedAt);
			
			if (obj.offical) {
				obj.officalPretty = 'true'
			} else {
				obj.officalPretty = 'false'
			}

		}

		function modifyUserProperties(obj) {
			if (obj.profile !=  undefined ){
				if (obj.profile.blurb  !=  undefined ) {
					obj.blurbPretty  = renderFormattedText(obj.profile.blurb)
				} else
				{
					obj.blurbPretty  = ''
				}
			} else
			{
				obj.blurbPretty  = ''
			};
			if (obj.id == 'system') {
				obj.profile.namePretty = 'System'
				obj.profile.nameNotPretty = 'System'
				obj.profile.username = 'System'
				obj.profile.usernameNotPretty = 'System'
				obj.profile.usernamePretty = 'System'
				obj.profile.avatar = ''
			} else {
				obj.profile.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + renderFormattedText(obj.profile.name) + '</a>';
				obj.profile.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + renderFormattedText(obj.profile.name, {removeParaTags: true}) + '</a>';
				if (obj.auth != undefined && obj.auth.local != undefined && obj.auth.local.username != undefined) {
					obj.profile.username = obj.auth.local.username
					obj.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + obj.auth.local.username + '</a>'
				} else {
					obj.profile.username = noUsernamePrefix + obj.profile.nameNotPretty 
					obj.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + noUsernamePrefix + obj.profile.nameNotPretty + '</a>'
				}
				obj.profile.usernamePretty = obj.profile.usernameNotPretty 
				obj.profile.avatar = createAvatar(obj);
			}
			if (obj.stats.class == 'wizard')  {
				obj.stats.classPretty = 'mage'
			} else {
				obj.stats.classPretty = obj.stats.class
			}
			obj.inbox.canPM = !obj.inbox.optOut;
			obj.creation  = reformatDate(obj.auth.timestamps.created);
			var nextBirthday = moment({
											year: moment().year(),
											month: moment(obj.auth.timestamps.created).month(),
											day: moment(obj.auth.timestamps.created).date(),
											hour: moment(obj.auth.timestamps.created).hour(),
											minute: moment(obj.auth.timestamps.created).minute(),
											second: moment(obj.auth.timestamps.created).second()
										})
			if (moment() > nextBirthday) nextBirthday = moment({
											year: moment().year()+1,
											month: moment(obj.auth.timestamps.created).month(),
											day: moment(obj.auth.timestamps.created).date(),
											hour: moment(obj.auth.timestamps.created).hour(),
											minute: moment(obj.auth.timestamps.created).minute(),
											second: moment(obj.auth.timestamps.created).second()
										})
			
			obj.creation.nextBirthday =  reformatDate(nextBirthday)
			
			
			obj.lastLoggedIn  = reformatDate(obj.auth.timestamps.loggedin);
			obj.lastDropItem  = reformatDate(obj.items.lastDrop.date);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
			
			//Round to 2 decimal places
			obj.stats.hpPretty = Math.round( obj.stats.hp * 100)/100;
			obj.stats.mpPretty = Math.round( obj.stats.mp * 100)/100;
			obj.stats.maxMPPretty = Math.round( obj.stats.maxMP * 100)/100;
			obj.stats.gpPretty = Math.round( obj.stats.gp * 100)/100;
			obj.stats.expPretty = Math.round( obj.stats.exp * 100)/100; 
			obj.stats.toNextLevelPretty = Math.round( obj.stats.toNextLevel * 100)/100;
			obj.stats.percentageMP = Math.round((obj.stats.mp / (obj.stats.maxMP) * 100) * 100)/100;
		}
		
		function reformatDate(dateString) {
				var formattedDate = myDateConverter(dateString, 'long');
				var shortDate     = myDateConverter(dateString, 'short');
				var relativeTime  = myDateConverter(dateString, 'relativeTime');
				var utcTime  = myDateConverter(dateString, 'utcTime');
				return { 'dateAndTime': formattedDate,
						 'shortDate': shortDate,
						 'relativeTime': relativeTime,
						 'utcTime': utcTime
				};
		}
		
		function createAvatar (user) {
			if (hideAvatar == false) {
				var wrapper = document.createElement('div');
				
				wrapper.appendChild(window.habiticaAvatar({user: user}));
				
				return wrapper.innerHTML;
			}
		}

		
		//////////////////////////////////////////////////////////////////////
		////   Sections 										   ////////////
		//////////////////////////////////////////////////////////////////////
		//Custom Section functions here.
		function formatOverviewSection(sectionId, title){
			var html = ''
			var htmlTOC = ''
			var htmlTOCDetail = ''
			var htmlReturnTOC = '<p><a href="#' + 'toc_' + sectionId + '" target="_self">Return To Section Table of Contents</a></p><hr/>'
			var subSectionTitle = ''
			var subSectionId = ''
			

			if (groupId != 'party') {
				subSectionId = 'SummaryAndCategories'
				subSectionTitle = 'Summary and Categories'
				htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
				html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
				html += '<p><span class="highlight">Categories:</span> '
				if (group.categories.length > 0 ) {
					$.each(group.categories, function(index, obj){
						html += toTitleCase((obj.name.replace(/_/g, ' '))) + '&nbsp;&nbsp;&nbsp;&nbsp;' 
					})
				} else {
					html += 'None'
				}
				if (group.summary != undefined) html += '<p><span class="highlight">Summary:</span> ' + renderFormattedText(group.summary) + '</p>'				
				html += htmlReturnTOC
			}

			//Description
			if (group.description != undefined) {
				subSectionId = 'Description'
				subSectionTitle = 'Description'
				htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
				html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'
				html += '<p>' + renderFormattedText(group.description) + '</p>'
				html += htmlReturnTOC
			}
			

			
			subSectionId = 'LeaderDetail'
			subSectionTitle = 'Leader Details'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
			html += '<p>Leader: ' + group.leader.profile.usernameNotPretty + '</p>'
			html += '<p>UserId: ' +  group.leader.id + '</p>'
			html += '<p>Display Name: ' + group.leader.profile.nameNotPretty + '</p>' 
			html += '<p>Last Active: ' + members[group.leader.id].lastActive.relativeTime + '</p>'
			html += '<p>Leader can only create challenges: ' + toTitleCase(String(group.leaderOnly.challenges))
			if ((userId == group.leader.id) || (userIsAdmin)) html += '&nbsp;&nbsp;&nbsp;&nbsp;<input class="div-perMemberStats_toggleLeaderOnlyChallenge" id="perMemberStats_toggleLeaderOnlyChallenge" type="submit" value="Toggle" />' 
			html += '</p>'
			html += htmlReturnTOC

			subSectionId = 'MemberBreakdown'
			subSectionTitle = 'Member Breakdown'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
			html += '<p>Total Members: ' + group.memberCount + '&nbsp;&nbsp;Members Fetched: ' + group.memberTotals.fetchCount + '</p>'
			html += '<p><table class=overview_classBreakdown>' + 
						'<tr><th>Warrior</th><th>Mage</th><th>Rogue</th><th>Healer</th></tr>' + 
						'<tr><td>' + group.memberTotals.class.warrior + '</td><td>' + group.memberTotals.class.wizard + '</td><td>' + group.memberTotals.class.rogue + '</td><td>' + group.memberTotals.class.healer + '</td></tr>' +
						'</table> ' + 
						'There are ' + group.memberTotals.underLevel10 + ' members under level 10 who might not have chosen their class yet.</p>'
			
			html += '<p><table class=overview_memberActivity>' + 
						'<tr><th></th><th>Active < 12 hr</th><th>Active 12 hr < 24 hr</th><th>Active 24 hr < 1 wk</th><th>Active 1 wk < 1 mth</th><th>Active > 1 month</th></tr>' +
						'<tr><th>Overall</th><td>' + group.memberTotals.activeLess12Hr + '</td><td>' + (group.memberTotals.activeLess24Hr - group.memberTotals.activeLess12Hr) + '</td><td>' + (group.memberTotals.activeLessWeek - group.memberTotals.activeLess24Hr) + '</td><td>' + (group.memberTotals.activeLessMonth - group.memberTotals.activeLessWeek) + '</td><td>' + (group.memberTotals.fetchCount - group.memberTotals.activeLessMonth) + '</td></tr>' +
						'<tr><th>Active</th><td>' + (group.memberTotals.activeLess12Hr - group.memberTotals.inInn_activeLess12Hr) + '</td><td>' + (group.memberTotals.activeLess24Hr - group.memberTotals.activeLess12Hr - (group.memberTotals.inInn_activeLess24Hr - group.memberTotals.inInn_activeLess12Hr)) + '</td><td>' + (group.memberTotals.activeLessWeek - group.memberTotals.activeLess24Hr - (group.memberTotals.inInn_activeLessWeek - group.memberTotals.inInn_activeLess24Hr)) + '</td><td>' + (group.memberTotals.activeLessMonth - group.memberTotals.activeLessWeek - (group.memberTotals.inInn_activeLessMonth - group.memberTotals.inInn_activeLessWeek)) + '</td><td>' + (group.memberTotals.fetchCount - group.memberTotals.activeLessMonth - (group.memberTotals.inInn - group.memberTotals.inInn_activeLessMonth)) + '</td></tr>' +
						'<tr><th>In Inn</th><td>' + group.memberTotals.inInn_activeLess12Hr + '</td><td>' + (group.memberTotals.inInn_activeLess24Hr - group.memberTotals.inInn_activeLess12Hr) + '</td><td>' + (group.memberTotals.inInn_activeLessWeek - group.memberTotals.inInn_activeLess24Hr) + '</td><td>' + (group.memberTotals.inInn_activeLessMonth - group.memberTotals.inInn_activeLessWeek) + '</td><td>' + (group.memberTotals.inInn - group.memberTotals.inInn_activeLessMonth) + '</td></tr>' +
					'</table></p> ' 
			html += htmlReturnTOC
			
			//Chat
			subSectionId = 'ChatBreakdown'
			subSectionTitle = 'Chat Breakdown'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
			if (group.chat.length > 0) {
				var chatDayPeriod = (Math.round((moment(group.chatTotals.lastChat.utcTime).diff(moment(group.chatTotals.firstChat.utcTime), 'hours'))/24*100)/100) 
				var displayTimePeriod = []
				var displayTimePeriod_notSystem = []
				var displayTimePeriod_system = []
				if (chatDayPeriod < 5){
					//set time into minutes
					timeDivision = (60 * 1000)
					timeDivisonName = ' min'
				} else if (chatDayPeriod < 20) {
					//set time into hours
					timeDivision = (60 * 60 * 100)
					timeDivisonName = ' hr'
				} else {
					//set time into days
					timeDivision = (60 * 60 * 24 * 1000)
					timeDivisonName = ' day'
				}
				//update arrays
				$.each(group.chatTotals.timePeriod, function(index, obj){
					displayTimePeriod.push(Math.round(obj / timeDivision))
				});
				$.each(group.chatTotals.timePeriod_notSystem, function(index, obj){
					displayTimePeriod_notSystem.push(Math.round(obj / timeDivision))
				});
				$.each(group.chatTotals.timePeriod_system, function(index, obj){
					displayTimePeriod_system.push(Math.round(obj / timeDivision))
				});
				
				if (debugShowObject) console.log(displayTimePeriod)
				
				html += '<p>Chat period: ' + group.chatTotals.firstChat.dateAndTime + ' to ' + group.chatTotals.lastChat.dateAndTime + ' (' + chatDayPeriod + ' days)</p>'
				html += '<p><table class=overview_chatActivity><caption>Chat anaylsis of time between messages</caption>' + 
						'<tr><th></th><th>No Of Lines</th><th>Mean</th><th>Median</th><th>Mode</th><th>Min Time Diff</th><th>Max Time Diff</th></tr>' 
				if (displayTimePeriod.length > 0) {		
					html += '<tr><th>Overall</th><td>' + group.chat.length + '</td><td>' + (Math.round(mean(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod) + timeDivisonName + '</td><td>' + largest(displayTimePeriod) + timeDivisonName + '</td>' 
				} else {
						html += '<tr><th>Overall</th><td>' + group.chat.length + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
				}
				if (groupId == 'party') {
					if (displayTimePeriod_notSystem.length > 0) {
						html += '<tr><th>Member</th><td>' + group.chatTotals.count_notSystem + '</td><td>' + (Math.round(mean(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod_notSystem) + timeDivisonName + '</td><td>' + largest(displayTimePeriod_notSystem) + timeDivisonName +  '</td>' 
					} else {
						html += '<tr><th>Member</th><td>' + group.chatTotals.count_notSystem + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
					}
					if (displayTimePeriod_system.length > 0) {
						html += '<tr><th>System</th><td>' + group.chatTotals.count_system + '</td><td>' + (Math.round(mean(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod_system) + timeDivisonName + '</td><td>' + largest(displayTimePeriod_system) + timeDivisonName +  '</td>' 
					} else {
						html += '<tr><th>System</th><td>' + group.chatTotals.count_system + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
					}
				}
				html += '</table></p> '
			} else {
				html +=  '<p>It appears a vow of silence has been taken, as there is no chat to report on.</p>'
			}
			html += htmlReturnTOC
			
			//Quest
			if (groupId == 'party') {
				subSectionId = 'QuestDetails'
				subSectionTitle = 'Quest Details'
				htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
				html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
				if (group.quest.key == undefined) {
					html += '<p>No Quest Active!</p>'
					html += '<p>Possible ' + Math.floor(user.party.quest.progress.up * 10) / 10 + ' damage for Boss Quest or ' + Math.floor(user.party.quest.progress.collectedItems * 10) / 10 + ' items collected for Collection Quest, if a quest starts before you next cron.'
				} else {
					var questStatus = ''
					if (group.quest.active) {
						questStatus='active' 
					} else {
						questStatus='pending' 
					}
					html += '<p><span class="highlight">' + quests[group.quest.key].text + '</span> ( ' + questStatus + ' )</p>'
					html += quests[group.quest.key].imgTag
					html += '<p>' + quests[group.quest.key].notes + '</p>'
					html += '<p><span class="highlight">Rewards: </span>' + quests[group.quest.key].drop.exp + ' XP, ' + quests[group.quest.key].drop.gp + ' Gold, ' + quests[group.quest.key].drop.rewardItemString
					html += '<p><span class="highlight">Total Participation: </span>' + group.quest.memberCount + '</p>'
					html += '<p><span class="highlight">Quest Participants in Inn: </span>' + group.quest.inInn_memberCount + '</p>'
					if (group.quest.active) {
						if (quests[group.quest.key].boss) {
							html += '<p><span class="highlight">Progress: </span>' + Math.round(group.quest.progress.hp * 100) / 100 + ' / ' + quests[group.quest.key].boss.hp
							if (quests[group.quest.key].boss.rage != undefined) html += '<p>Rage: ' + Math.round(group.quest.progress.rage * 100) / 100 + ' / ' + quests[group.quest.key].boss.rage.value
							html += '<p><span class="highlight">Your Pending Damage: </span>' +  Math.floor(user.party.quest.progress.up * 10) / 10
						} else {
							var collectionString = ''
							$.each(group.quest.progress.collect, function(index, obj){
								collectionString += obj + ' of ' + quests[group.quest.key].collect[index].count + ' ' + quests[group.quest.key].collect[index].text + ' ' //Put totals?
							});
							html += '<p><span class="highlight">Progress: </span>' + collectionString					
							var collectionStringUser = ''
							$.each(user.party.quest.progress.collect, function(index, obj){
								collectionStringUser += obj + ' of ' + quests[group.quest.key].collect[index].text + ' ' //Put totals?
							});
							if (collectionStringUser == '' && user.party.quest.progress.collectedItems > 0) collectionStringUser = user.party.quest.progress.collectedItems + ' random objects. (Need to get back to your tent to see what is in your bag).'
							html += '<p><span class="highlight">Your Pending Progress: </span>' + collectionStringUser						}
					}  else {					
						html += '<p><span class="highlight">Type: </span>'+ toTitleCase(quests[group.quest.key].typeOf) + ' (' +  quests[group.quest.key].defeatBy + ')'
						if (quests[group.quest.key].boss) {
							html += '<p><span class="highlight">Your Pending Damage: </span>' +  Math.floor(user.party.quest.progress.up * 10) / 10 
						} else {
							html += '<p><span class="highlight">Your Pending Progress: </span>' +  Math.floor(user.party.quest.progress.collectedItems * 10) / 10 
							
						}
						html += ' if the quest starts before you next cron.</p>'
					}
					
					if (group.quest.key != undefined) {
						html += '<p><span class="highlight">Est of Completion: </span>' 
						
						if (completedStats.by == '') {
							html += 'Not enough work yet to complete the quest in next 24 hours. (Keep battling those tasks!) '
						} else {
							if (moment().isBefore(completedStats.time.utcTime)) {
								html += completedStats.time.relativeTime + ' by ' 
							} else {
								html += 'Any moment now with ' 
							}
							
							html += completedStats.by + '. '
						}	
						
						html += 'See <span class="showHideToggle" data-target="memberDamageSection" data-closemainsections="true">Member Quest Progress</span> for more details. ' 
					}
					
					html += '<p><span class="highlight">Quest Owner: </span>' + group.quest.leaderProfile.usernameNotPretty + ' (UserId: ' +  group.quest.leader + '   Display Name: ' + group.quest.leaderProfile.nameNotPretty + '   Last Active: ' + group.quest.leaderProfile.lastActive.relativeTime + ') </p>'
				}
				html += htmlReturnTOC
			}
			
			htmlTOC += '<nav role="navigation" class="table-of-contents">'
			htmlTOC += '<h3 id="' + 'toc_' + sectionId + '">Table Of Contents</h3>'
			htmlTOC += '<ul>'
			htmlTOC += htmlTOCDetail
			htmlTOC += '</ul></nav>'
			htmlTOC += '<hr/>'

			html = htmlTOC + html
			
			
			
			
			//Finally just return the data!
			if (! html) {
				return;
			} 
			var id    = sectionId + 'Section';
			var orderId = sectionId;
			var refreshId = sectionId + SECTIONREFRESH 
			html = '<span id="' + refreshId + '">' + html + '</span>'		
			TOC[orderId] = {'target': id, 'title':  title};
			MAIN[orderId] = {'id': id, 'title': title, 'refreshHtml': html, 'refreshId': refreshId, 'longContent': true,
				'html': html};
		}
		
		///////////////////////////////////////////////////////////////////////
		////   Custom events  for custom Sections above             //////////
		/////////////////////////////////////////////////////////////////////
		$(document).unbind('click'); //remove random elements listeners

		if ((userId == group.leader.id) || (userIsAdmin)) {
			$(document).on('click', '.div-perMemberStats_toggleLeaderOnlyChallenge', function(event){
				if (debug) console.log('debug #perMemberStats_toggleLeaderOnlyChallenge');
				var newValue = !group.leaderOnly.challenges
				postToggleLeaderOnlyChallenge(newValue);
			});
		}
		
		//////////////////////////////////////////////////////////////////////
		//sectionTable Functions
		//////////////////////////////////////////////////////////////////////
		function formatTableSection(sectionId, title){
			var id    = sectionId + 'Section';
			var orderId = sectionId;
			var tableSectionId = sectionId + 'display';
			var subTitle = sectionTables[sectionId].subTitle()
			var refreshId = sectionId + SECTIONREFRESH 
			var html = formatTableData(subTitle, refreshId, tableSectionId);
			if (! html) {
				return;
			}
			TOC[orderId] = {'target': id, 'title':  title};
			MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
				'html': html, 'refreshHtml': subTitle, 'refreshId': refreshId,
				'dataSetTblSection': tableSectionId, 'function': constructTable, 
				'functionPar':  [sectionId, sectionTables[sectionId].dataSet, sectionTables[sectionId].dataSetHeader, tableSectionId]};
		}
		
		
		//Function used by sections to create HTML To display table
		function formatTableData(subText, refreshId, tableId) {
			//Used by sections above if a table is required in there HTML
			var html = '';
			
			html += '<table id="' + tableId + '" class="display" width="100%"></table>'

			if (html) {
				return '<span id="' + refreshId + '">' + subText + '</span><p><div id="headerExport"></div></p>' + html ;
			}
			else {
				return '';
			}
		}


	}
	
}


if (debug) console.log('debug 99');	
});
</script>	


<style>

/*********************************************************************
****   Page-wide   ***************************************************
*********************************************************************/
body {
    font-family: Helvetica, Arial, sans-serif;
    font-size: 14px;
    background-color: rgb(173, 208, 215);
}



#innerBody {
    margin: 20px;
    padding: 5px 20px 30px 20px;
    background-color: rgb(242, 242, 230);
}
#loading {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#loading ul {
    font-size: 0.8em;
}
#loading ul a {
    color: orange;
}


#posting {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#posting ul {
    font-size: 0.8em;
}
#posting ul a {
    color: orange;
}

.narrowContent {      /* The data should be as wide as the user's window   */
    max-width: 500px; /* but some explanatory paragraphs should be narrow. */
}


hr {
    width: 95%;
}
hr.padded {
    margin-top:    1em;
    margin-bottom: 2em;
}

.show {
    display: block;
}
.hide {
    display: none;
}
.clear {
    clear: both;
}

.subheading {
    font-weight: bold;
}
.highlight {
    font-weight: bold;
}
.lowlight { /* like highlight but less so */
    font-style: italic;
}
.explanation {
    font-style: italic;
}
abbr {
    border-bottom: 1px dashed black;
}
img.emoji {
    margin-bottom: -0.25em;
}
.forCopyPaste {
    /* used to add blank lines that we want when copying text to clipboard,
       but we don't want to see extra whitespace on the screen */
    margin-top: -1em;
}
ul.padded > li {
    padding: 3px 0;
}

.neutral {
    background-color: #fffbd0; /* yellow */
}
.danger {
    background-color: #ffcccc; /* red */
    /* background-color: #F5A9A9; */ /* darker red */
}
.safe {
    background-color: #bdd8fc; /* blue */
    /* green+red and green+yellow are not good for colour-blind people */
}


/*********************************************************************
****   Page-wide Data Tables   ********************************
*********************************************************************/


a.dt-button.columnGroupButton {
	color: orange;
}

a.dt-button.cardButton {
	color: orange;
}
 
a.dt-button.tranformButton {
	color: orange;
}

a.dt-button.removeUserButton {
	color: orange;
}

a.dt-button.changeLeaderButton {
	color: orange;
}

a.dt-button.messageUserButton {
	color: orange;
}

div.dt-button-collection {
	width: 180px;
}

a.dt-button.postChatButton {
	color: blue;
}

a.dt-button.questAcceptButton {
	color: blue;
}

a.dt-button.questRejectButton {
	color: blue;
}

a.dt-button.questStartButton {
	color: blue;
}

a.dt-button.questLeaveButton {
	color: blue;
}

a.dt-button.questAbortButton {
	color: blue;
}

/*********************************************************************
****   Page-wide Show/Hide Toggling   ********************************
*********************************************************************/
.mainSectionClose,
.showHideToggle,     /* for toggling by id */
.showHideToggleClass /* for toggling by class */
{
    cursor: pointer;
    text-decoration: underline;
    color: purple;
}
.closer { /* as in "a thing that closes", not "nearer" */
    margin-top: 30px;
    padding-top: 15px;
    padding-bottom: 15px;
}
.closer:hover {
    border: 1px dashed lightgrey;
}
.developerData {
    font-family: monospace;
}


/*********************************************************************
****   Header   ******************************************************
*********************************************************************/
h1 {
    float: left;
}
h1>a:first-child { /* "Habitica" link in header */
    color: black;
    text-decoration: none;
}
h1>a:first-child:hover { /* "Habitica" link in header */
    text-decoration: underline;
}
h1 span {
    font-size: 0.5em;
}
h2 {
    margin-top: 30px;
}

#headerExtras .showHideToggle {
    white-space: nowrap;
}
#userNameDisplay {
    text-align: right;
    font-weight: bold;
    font-size: 2em;
    margin-bottom: 10px;
}

#groupNameDisplay {
    text-align: left;
    font-weight: bold;
    font-size: 2em;
    margin-bottom: 10px;
}

#explanationAndClearLinks {
    text-align: right;
}
#explanationAndClearLinks span {
    padding-left: 10px;
}


/*********************************************************************
****   Version History   *********************************************
*********************************************************************/

#versionChanges dl {
    margin-left: 30px;
}
#versionChanges dl dt {
    font-size: 1.15em;
    font-weight: bold;
}
#versionChanges dl dt .date {
    padding-left: 10px;
    font-size: 0.8em;
    font-weight: normal;
}
#versionChanges .showHideToggle {
    padding-bottom: 15px;
    margin-bottom: 10px;
}

/*********************************************************************
****   API Form and Documentation   **********************************
*********************************************************************/

#documentationAndForm > div {
    max-width: 770px;
}
#documentationAndForm #documentationAndFormClose {
    display: none;
    max-width: 100%;
}
#documentationAndForm div h2 {
    font-size: 1.3em;
}
#documentationAndForm li {
    margin-bottom: 10px;
}

#userApiDetailsForm {
    margin: 30px;
}
#userApiDetailsForm fieldset {
    max-width: 40em;
}
#userApiDetailsForm fieldset label,
#userApiDetailsForm fieldset input[type="submit"] {
    display: block;
    float: left;
    clear: left;
    margin: 9px 0;
}
#userApiDetailsForm fieldset input[type="button"] {
    display: block;
    float: left;
    clear: left;
    margin: 9px 0;
}
#userApiDetailsForm fieldset label span {
    display: block;
    float: left;
    width: 11em;
}
#userApiDetailsForm fieldset label input {
    float: left;
    width: 30em;
}
#userApiDetailsForm input[type="checkbox"] {
    width: auto;
}
#userApiDetailsForm fieldset p {
    clear: both;
}
#userApiDetailsForm legend .highlight {
    font-size: 1.3em;
}
#userApiDetailsForm fieldset li {
    margin-bottom: 7px;
}



/*********************************************************************
****   Dashboard   ***************************************************
*********************************************************************/
#DASHBOARD ul {
    float: left;
}
#DASHBOARD li {
    text-align: center;
    width: 120px;
    background-color: #fffbd0; /* yellow */
    border: 1px;
    padding: 4px;
    margin-right: 4px;
    float: left;
    list-style-type: none;
}
#DASHBOARD li.showHideToggle {
    text-decoration: none;
    color: black;
}
#DASHBOARD li > div {
    box-shadow: 1px 1px 1px 1px #666666;
}
#DASHBOARD .value {
    font-size: 2.15em;
    font-weight: bold;
    padding: 2px;
}
#DASHBOARD .label {
    font-size: 0.75em;
    padding: 1px;
}
#DASHBOARD .dropCap {
    font-size: 0.7em;
}


/*********************************************************************
****   Table Of Contents   *******************************************
*********************************************************************/
ul#tableOfContents {
    list-style-type: none;
}
ul#tableOfContents ul {
    list-style-type: none;
    margin-left: 1em;
    padding: 0;
}
ul#tableOfContents li {
    font-size: 1.1em;
    padding: 2px 0;
}
ul#tableOfContents > li {
    float: left;
    margin-right: 20px;
}


/*********************************************************************
****   Specific Sections   *******************************************
*********************************************************************/
#MAIN > * {
    display: none; /* all sections hidden by default */
}

#overviewSection h1 {
	 float: none
}

#overviewSection table tr td {
    border: 2px solid lightgrey;
	text-align: center;
	padding: 5px;
}
</style>
</head>
<body><div id="innerBody">	
<h1><a href="https://habitica.com/">Habitica</a> Party & Guild Data Tool
    <span class="showHideToggle" data-target="versionChanges" data-closemainsections="true">(v4.1)</span></h1><!-- VERSION TOGGLE -->
<div id="headerExtras"></div>
<hr class="clear" />
<div id="headerGroupExtras"></div>
<hr class="clear" />

<div id="loading">
     <div class="dblClickError hide">
        <p>Did you double click the Re-Fetch? I have too many things to count here. The error below may not be valid. Check for duplicate usernames in the tables below before reporting.</p>
    </div>
    <div class="error hide">
        <p>ERROR! The membership count does not match what is recorded. Please report in the <a href="https://habitica.com/groups/guild/a29da26b-37de-4a71-b0c6-48e72a900dac" target="_blank">Report Bug Guild</a> that<br> 
        <span id="groupDetail">GROUP name (ID: 1234)</span> membership count does not match the listed users. <span id="groupDetailCount">(Stated: 1 Estimated: 2)</span> </p>
    </div>
    <div class="good hide">
        <p>Please wait. Fetching data from
        <span id="serverName">Habitica</span>... <span id="statusFetch"></span></p>
    </div>
    <div class="bad hide">
        <p>There was an error obtaining your data.</p>
        <ul class="padded">
			<li>Check your group id is either "party" or Guild Id which is a string of characters similar to your UID. The Guild ID appears at the end of the URL. Eg. 2ff9822b-27f2-4774-98da-db349b57a38e</li>
            <li>Please reload the page and then check that your <a href="https://habitica.com/user/settings/api">User ID and API Token</a> are correct.</li>
            <li>If you're using Internet Explorer, try another browser. <a href="https://www.google.com/intl/en/chrome/browser/">Chrome</a> or <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a> will be more reliable.</li>
            <li>If the page's URL starts with "http://" change it to start with "https://" (or just use <a href="https://oldgods.net/habitica/cTheDragons/group.html">this correct link</a>).</li>
            <li>If neither of those help, contact me! See <strong>"Help and Contact Details"</strong> at the bottom of this page.</li>
        </ul>
    </div>
</div>
<div id="posting">
	<div class="good hide">
		<p>Please wait. Posting data to
		<span id="serverName">Habitica</span>... <span id="statusPost"></span></p>
	</div>
</div>

<div id="versionChanges" class="hide"><!-- VERSION SECTION -->
    <h2>Version History</h2>
    <dl>
		<dt>4.1 - Not a Warning about Skynet<span class="date">2020-01-24</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Robot quest now plays with the other pets in Pet Quests Completed.</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Warning now includes message if the fetch button you click twice, thrice, or wow giving that button a work out times.</li>
                </ul>
            </li>
		</ul></dd>
		<dt>4.0 - Questing for Some Magic<span class="date">2020-01-19</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li class="subheading">Magic Quest Completed</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Username used in Member Quest Progress blurb</li>
					<li>Removed ! from Quests Header. (It is important, just not that important)</li>
					<li>Language clean-up with What's Next with practical statement of my time without a time machine.</li>
					<li>All sections under Quests: Adding a note if not all party members fetched information may not be correct.</li>
                </ul>
            </li>
	        <li>Bug Fixes:
                <ul>
					<li>Showing correctly which members have rejected a quest when a quest has started.</li>
				</ul> 
            </li>	
		</ul></dd>
		<dt>3.8 - We are counting here!<span class="date">2019-06-04</span></dt>
        <dd><ul>
	        <li>Bug Fixes:
                <ul>
					<li>Fix issue with previous quests totals being handled as text instead of number.</li>
				</ul> 
            </li>	
		</ul></dd>
		<dt>3.7 - Did you say something?<span class="date">2019-06-02</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Refactored chat text to handle new system format with chat.info.</li>
					<li>Rename Other Details in Overview to Leader Details. Formatted text.</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Add all x-client calls except content (no header required)</li>
                </ul>
            </li>
		</ul></dd>
		<dt>3.6 - Clunky Lines<span class="date">2019-05-01</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Able to put carriage returns into message (Clunky but will do for now).</li>
					<li>Made usernames and display names linked to Habitica Profile Page.</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Updated reference & email for spam to generic Admin.</li>
                </ul>
            </li>
	        <li>Bug Fixes:
                <ul>
					<li>Adding posted date back to mama bear view for Inbox.</li>
					<li>Adding Message Id back.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>3.5 - Pardon, what was your name?<span class="date">2018-12-23</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Showing Alt usernames when username not defined.</li>
				</ul> 
            </li>	
	        <li>Bug Fixes:
                <ul>
					<li>Testing if username set for owners of challenges.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>3.4 - Rose by any other name<span class="date">2018-12-18</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Adding usernames for all tables with UserId</li>
					<li>Expanding text for Leader and Quest owner in Overview</li>
					<li>Adding more detail about the Leader in title</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Clean-up and added text to the section descriptions, based on the latest changes from this and last two changes.</li>
					<li>Clean-up of column justification; Dates & Text Left justified, Numbers right justified, Boolean values centred.</li>
                </ul>
            </li>				
	        <li>Bug Fixes:
                <ul>
					<li>Member Quest Progress in Collection Quests: Showing the correct outstanding items by accounting for over collected items.</li>
					<li>Member Quest Progress in Collection Quests: Showing the % for quests with 3 or more items (I really should of read my own formula).</li>
               </ul>
            </li>
		</ul></dd>
		<dt>3.3 - May I take my leave?<span class="date">2018-08-03</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Add Abort Quest Button in Member in Quests Participation.</li>
					<li>Add Leave Quest Button in Member in Quests Participation.</li>
					<li>Add Required to Finish column in Member Quest Progress.</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Add highlighting to Member Quest Progress to clearly see the numbers left in Member Quest Progress.</li>
					<li>Remove the quest name being stated twice in Member Quest Progress.</li>					
                </ul>
            </li>				
	        <li>Bug Fixes:
                <ul>
					<li>Allowing the last member to be a Lost Duck and go search for it (not just fail).</li>
					<li>Quest Participation are always created now and tested to hide or show for each item. (Ie buttons display correctly despite if leader change/next quest starts).</li>
					<li>Pending damage only calculates with those active in the quest.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>3.2 - Are we nearly there yet?<span class="date">2018-07-05</span></dt>
        <dd><ul>
	        <li>Bug Fixes:
                <ul>
					<li>Fix issue with pending damage for boss quests on who will complete.</li>
				</ul> 
            </li>	
		</ul></dd>
		<dt>3.1 - Are we there yet? (Pending Quest Progress)<span class="date">2018-07-03</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Created column to show pending damage in quest progress.</li>
					<li>Determining and show who is likely to end the quest and when with party total of damage.</li>
					<li>Determining and show the probability of when a collection quest is likely to end.</li>
					<li>Modifying sort on Member Quest Progress by cron to allow easy scan of pending damage.</li>
					<li>Adding totals of party own scrolls in quests sections.</li>
				</ul> 
            </li>	
		</ul></dd>
		<dt>3.0 - Don't let the server get you down<span class="date">2018-04-30</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Added the ability to handle timeouts when fetching members and list of members.</li>
					<li>Hide Avatar images now on as default to avoid memory issues.</li>
				</ul> 
            </li>	
		</ul></dd>
		<dt>2.9 - Emperor's New Clothes<span class="date">2018-02-24</span></dt>
        <dd><ul>
	        <li>Bug Fixes:
                <ul>
					<li>Handled if appearance is not populated in chat message. (Further work to be done in the area).</li>
               </ul>
            </li>
		</ul></dd>
		<dt>2.8 - Refactor URL Parameter code<span class="date">2018-02-24</span></dt>
        <dd><ul>
	            <li>Features:
                <ul>
					<li>Added other url parameters, bear and porridge.</li>
					<li>Added json of appearance to chat.</li>
				</ul> 
            </li>	
			<li>Documentation:
                <ul>
					<li>Fix thanks for Blade. (Link to code supplied).</li>
                </ul>
            </li>				
	        <li>Bug Fixes:
                <ul>
					<li>Url parameters apply independent of whether or not the user id parameter is supplied. (Thank you @Accio Books!)</li>
					<li>Checkbox url parameters can be set to false.</li>
					<li>Added some unbinding of code to avoid multi-events</li>
					<li>No longer tries to post a null to chat.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>2.7 - Notifications, Summary & Categories<span class="date">2017-11-10</span></dt>
        <dd><ul>
	            <li>Features:
                <ul>
					<li>Allow the option to clear chat notification (default on)</li>
					<li>Added ability to hide Avatar Image for Faster Loading</li>
					<li>Show in Overview Leader Can Only Create Challenges.</li>
					<li>Added button to toggle Leader Can Only Create Challenges if leader.</li>
					<li>Added Summary and Category information for Guild</li>
					<li>Remove deprecated Leader Message.</li>
					<li>Now shows rage bar information if quest contains one.</li>
					<li>Added hide_avatar and max and clear_chat as url options.</li>
				</ul> 
            </li>	
	        <li>Bug Fixes:
                <ul>
					<li>Avatar image always displays even if column is hidden (Thank you @Blade)</li>
					<li>Quest Buttons now show and hide correctly.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>2.6 - Pretty Pictures<span class="date">2017-10-31</span></dt>
        <dd><ul>
	            <li>Features:
                <ul>
					<li>Added Avatar Image. Deprecating Avatar link (Not currently available).</li>
					<li>Updating URL to new website format.</li>
					<li>Better error with POST functions handling.</li>
					<li>Direct links to guilds at Habitica</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Clean up of code.</li>
					<li>Minor fixes to formatting of check boxes.</li>
                </ul>
            </li>		
		</ul></dd>
		<dt>2.5 - Quest of Chat<span class="date">2017-09-30</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Can now post messages from the chat sections.</li>
					<li>Now can see Pending and Rejected Quest participants.</li>
					<li>Adding Accept, Reject and Start Quest buttons.</li>
					<li>Can see pending damage in overview section.</li>
					<li>Updating URL to new website format.</li>
					<li>Deprecating Avatar link (Not currently available).</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Clean up of code.</li>
					<li>Some better error handling.</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
					<li>Entering zero max members now only gets the leader and if applicable quest details.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>2.4 - Really I Can Count!<span class="date">2017-08-19</span></dt>
        <dd><ul>		
	        <li>Bug Fixes:
                <ul>
					<li>Better handling of null strings with markdown.</li>
					<li>Mage totals now show in overview.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>2.3 - No more undefined collecting<span class="date">2017-08-07</span></dt>
        <dd><ul>	
	        <li>Bug Fixes:
                <ul>
					<li>Collection quests now show progress correctly in Overview.</li>
					<li>documentation / options always shows next to the re-fetch button</li>
					<li>Typo Successfully</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>2.2 - Throttling the Luck<span class="date">2017-07-25</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Adding Good Luck Cards. Putting Cards in alphabetical order.</li>
					<li>Adding in throttling for every 1500 member requests. (Required to slow down "member fetch" as servers were not handling requests.)</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Add noted regarding throttling</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
					<li>Typo Maximum (Thanks @Accio Books!)</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>2.1 - We Want Our Classes Back!<span class="date">2017-07-07</span></dt>
        <dd><ul>
	        <li>Documentation:
                <ul>
                    <li>Added message PMs are filtered based on fetched members only.</li>
					<li>Minor wording changes for the section descriptions.</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
					<li>Putting Classes back into tables. No wandering off in future! Thank you @Kingmaker!</li>
                    <li>Handle no challenge owner.</li>
					<li>If selecting party from drop down see the party sections too.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>2.0 - Mods, Likes, Cards!<span class="date">2017-07-04</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li class="subheading">Challenge List</li>
					<li class="subheading">Chat Likes</li>
					<li class="subheading">PMs</li>
					<li>Add Likes and Participant Likes Counts to Chat Export.</li>
					<li>Added Message, Change Leader and Remove User to all tables if guild/party leader. Remove Leadership tools as no longer required.</li>				
					<li>Added Cards Get Well and Congrats.</li>
					<li>Allowed user to have a select list of their guilds & party.</li>
					<li>Mods have access to Leadership Tools.</li>
					<li>Names now render with markdown based on porridge option.</li>
					<li>groupId added for URL variable</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Minor text change re member activity.</li>
					<li>Slight modification to the message warning to make it clearer (Added extra punctuation).</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Removed incorrect references to the Data Display Tool. (Thank you @Alys)</li>
					<li>Cold porridge now shows carriage returns.</li>
					<li>Zero Chat Guilds are now fetch again</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>1.7 - Lets have cake! Celebrate birthdays & no more need rearrange the furniture when refreshing.<span class="date">2017-03-04</span></dt>
        <dd><ul>
			<li>Features
                <ul>
					<li>Tables no longer loose there settings when changing Porridge option OR re-fetching data. (Fetching will reset the table settings to the options). YAH!</li>
					<li class="subheading">Chat Export only System Msg</li>
					<li>Displaying error message if the recorded (group.count) is incorrect</li>
					<li>Adding to the Member List, Born (papa) and Next Birthday(mama).</li>
					<li>Removing UID for all sections in Baby option.</li>
					<li>Changing the ordering for Pets Quests so the most not completed first and then completed afterwards</li>
					<li>Changing default option to Hot. (Voted prefer to have best display option then best export option).</li>
				</ul>
			</li>
			<li>Bug Fix
                <ul>
					<li>Forced rounding of damage figures. (Still don't why I had to do it but I did it anyway).</li>
	
				</ul>
			</li>
            <li>Documentation
                <ul>
					<li>Minor edits due to renaming of guilds & clean up of version history</li>
					<li>Adding notification stats may be incorrect for Buffs, Transformational items and Quest Progress if player name changed recently.</li>
				</ul>
			</li>	
		</ul></dd>	
	
		<dt>1.6 - Minor Rearrange<span class="date">2017-01-16</span></dt>
        <dd><ul>
            <li>Documentation Code
                <ul>
					<li>Moving Null.html out of the top directory</li>
					<li>Cleaning up documentation</li>
				</ul>
			</li>	
		</ul></dd>
		<dt>1.5 - PMs, Buffing, Transformation & Quest Progress Stats<span class="date">2017-01-16</span></dt>
        <dd><ul>
            <li>Features
                <ul>
					<li class="subheading">Member Buffs & Transformation</li>
					<li class="subheading">Member Quest Progress</li>
					<li>Added the ability to send cards to Party members and rename Transformation Items to Transformation Items & Cards</li>
					<li>Hiding Last Born and showing Last Cron for Mama Bear format in Member Stats</li>
					<li>Added button Message User to Leadership Tools to allow to bulk PM members if you are the Leader. (It is ugly, I hate it but I might not be able to do much more for while)</li>
					<li>Added ability to PM user as well as email when removing users through Leadership Tools. (Yes still ugly too).</li>
					<li>Added ability to see users image with direct link from Habitica. (For @Lorem - Best I can do till they rewrite the website.) </li>
				</ul>
			</li>
			<li>Bug Fix
                <ul>
					<li>Fixing the calculation stats for 100 and over & seasonal gear</li>
				</ul>
			</li>
		</ul></dd>
		<dt>1.4 - Thanks @Alys For all you do<span class="date">2016-12-06</span></dt>
        <dd><ul>
            <li>Documentation
                <ul>
					<li>Minor word change on overview. (Thank you @Alys)</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>1.3 - Further Polishing from the Pirates<span class="date">2016-12-05</span></dt>
        <dd><ul>
			<li>Features
				<ul>
					<li>Adding a feedback message for Removing users and Transformation Items (Thanks @SweetenedPoison for spotting that one.)</li>
					<li>Removed the option to sort by relative time period to make it less confusing (Thanks @citrusella, the serving wench for spotting that one.)</li>
				</ul>	
			<li>Bug Fix
                <ul>
					<li>Handled missing contributor tier level but has contributor text. (Thank you @froggily for spotting that one.)</li>
				</ul>
            <li>Documentation
                <ul>
					<li>Section Change "There is X members under level 10..." to "There are X members under level 10...." (Thank you @tricksy.fox)</li>
					<li>Added commas between rewards lists. (Thank you @tricksy.fox)</li>
					<li>Right justifying some table information to make it an easier read. (Thank you @Floodid for spotting this.)</li>
					<li>Adding text to the top of the Transform items and Leadership Tools on how to select multiple rows (Thank you @Alys for spotting this)</li>
					<li>Adding text to the top of the Pet Quest regarding the number of times required. (Thank you @Accio Books! for spotting this)</li>
					<li>Adding relevant text for Quests and chat</li>
					<li>Changing range with Min and Max time diff to make it clearer. (Thanks @tricksy.fox)</li>
					<li>Max Fetch is rounded up to the nearest 30 (with maybe an extra 1 or 2) (Thank you @mememry for spotting this)</li>
					<li>Many grammar changes which made me realised I did not like English at school. (Thank you @Floodid (who speaks English as a second language) for providing the new text.)</li>
					<li>Further grammar changes (Thank you @CloJo - Glad grammar is your thing).</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>1.2 - Updating the documentation<span class="date">2016-11-26</span></dt>
        <dd><ul>
			<li>Features:
                <ul>
					<li>Adding ability to change leaders in LeaderShip tools.</li>
				</ul>
            <li>Documentation
                <ul>
					<li>Changed Last Logged On to Last Cron to make it clear</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>1.1 - Killing the Typo Bug<span class="date">2016-11-26</span></dt>
        <dd><ul>
            <li>Bug Fix
                <ul>
					<li>Getting the Actually leader not the quest leader if it missing.</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>1.0 - Release Version. Shiny!<span class="date">2016-11-25</span></dt>
        <dd><ul>
			<li>Features
                <ul>
					<li>Finalising Transformation Items</li>
					<li class="subheading">Overview Section</li>
					<li class="subheading">Leadership Admin Section including remove users</li>
					<li>Last Activity Added to Members Activity</li>
					<li>Added Rewards to Quest sections</li>
					<li>Added Pet Name to Pets Table</li>
                </ul>
            </li>
            <li>Bug Fix
                <ul>
					<li>Transformation Info to display! Thanks Blade!</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>0.4 - Polishing and Adding the last of the data <span class="date">2016-11-16</span></dt>
        <dd><ul>
			<li>Features:
                <ul>
					<li>Further working on Transformation items with Blade</li>
                </ul>
            </li>
		</ul></dd>
		<dt>0.3 - More Sections & Dashboard <span class="date">2016-11-15</span></dt>
        <dd><ul>
			<li>Features:
                <ul>
					<li class="subheading">Dashboard</li>
					<li class="subheading">All Quest Completed Section</li>
					<li class="subheading">Pet Quests Completed Section</li>
                    <li class="subheading">Use Transformation Item (Not completed)</li>
                </ul>
            </li>
            <li>Bug Fix
                <ul>
					<li>Remove the double fetch of users</li>
					<li>Only copy/print Export visible columns</li>
				</ul>
			 </li>
		</ul></dd>
		<dt>0.2 - Bug Fix <span class="date">2016-11-03</span></dt>
        <dd><ul>
            <li>Bug Fix
                <ul>
					<li>Fix the ordering of columns in Quest Participation</li>
				</ul>
			 </li>
		</ul></dd>
        <dt>0.1 - beta release <span class="date">2016-11-02</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
                    <li class="subheading">Member List Section</li>
					<li class="subheading">Member Activity Section</li>
					<li class="subheading">Member Activity (Relative) Section</li>
					<li class="subheading">Member Stats Section</li>
					<li class="subheading">Quests Participation Section</li>
                    <li class="subheading">Chat Export Section</li>
					<li class="subheading">Chat Export without System Messages Section</li>
                </ul>
            </li>
            <li>Documentation:
                <ul>
                    <li>Privacy and security notes (also related comments within the code)</li>
                    <li>What's On This Page? (descriptions of each feature)</li>
                    <li>Possible Future Features</li>
                    <li>Suspected Bugs (no support for old browsers; mobile support unknown)</li>
                    <li>Help and Contact Details</li>
                </ul>
            </li>
        </ul></dd>
    </dl>
    <div class="showHideToggle closer" data-target="versionChanges" data-scrolltotop="true">close version history <span class="lowlight">(or click the version number again to close)</span></div>
    <hr />
</div><!-- end of div id="versionChanges" -->


<div id="DASHBOARD"></div>
<div id="TOC"></div>
<div id="MAIN"></div>

<div id="documentationAndForm">
   <p>This page shows you certain information from your <a
   href="https://habitica.com/">Habitica</a> account. You can read the
   full list below, or just enter your details and try it out.</p>

    <iframe src="js/null.htm" id="formPasswdSaveFix" name="formPasswdSaveFix" style="display:none"></iframe><!-- DAMN YOU CHROME!! DAMN YOU!!!! http://stackoverflow.com/a/9116737 -->
    <form id="userApiDetailsForm" method="POST" action="" target="formPasswdSaveFix">
        <fieldset>
            <legend><span class="highlight">Enter your Habitica API details</span>
            (from the <a href="https://habitica.com/user/settings/api">Settings
             -&gt; API page</a>)
            </legend>
            <label for="userId"><span>User ID</span>
                <input type="text" name="userId" id="userId"/>
            </label>
            <label for="apiToken"><span>API Token</span>
                <input type="password" name="apiToken" id="apiToken"/>
            </label>
			<div id="groupSelector"></div>
			<label for="maxMembersToFetch"><span>Max Members Details</span>
                <input type="number" name="maxMembersToFetch" id="maxMembersToFetch" value="120" />
            </label>
			<label for="hideAvatar"><span>Hide Avatar Images? (for faster load)</span>
                <input type="checkbox" name="hideAvatar" id="hideAvatar" checked/>
            </label>
			<label for="clearNotification"><span>Clear chat notification?</span>
                <input type="checkbox" name="clearNotification" id="clearNotification" checked/>
            </label>
			<div id="exportOptionSelector"></div>
            <input class="div-fetchData" type="submit" value="Fetch Group Data" />
			<p class="highlight">Guild ID/Party:</p>
			<p>Enter either the word <i>party</i>, the Guild ID, or the URL for the Guild. The Guild ID is a string of characters similar to your User ID, e.g. 2ff9822b-27f2-4774-98da-db349b57a38e. The Guild ID appears at the end of the URL or on the left hand panel on the website. It is not the name of the guild. You can always just post the entire URL, which is much easier!</p>
			<p class="highlight">Max Members to Fetch:</p>
			<p>Max Members to fetch indicates how many people you want to fetch. The lesser the number the quicker the page will load. 120 users will take approximately 50 seconds; 1200 users approximately 4 minutes. Members fetched will always round up to the nearest 30, with the possible for extra 1 or 2 users for the leader or quest leader. There is a 120 second pause for every 1500 members requested to ensure Habitica Servers are not overloaded.</p>
			<div id="exportOptionDesc"></div>
            <p class="highlight">Privacy and security notes:</p>
            <ul>
            <!--<li>If you access this page from the Data menu on the Habitica
            website, your User ID will be automatically added to the form
            above.</li> $$$ Maybe one day when the tool that good--->
            <li>Your API Token is a password - do not share it with anyone,
            not even the maintainer of this page if you are seeking help.</li>
            <li>When you enter your User ID and API Token here and click
            "Fetch My Data", your ID and Token are sent to Habitica's servers.
            They are not sent anywhere else.
            To confirm that, you can ask someone who knows the JavaScript
            programming language to examine the source of this page.</li>
            <li>This page does not save your User ID and API Token to any
            location, but your browser might, if it has been configured to
            save form and password information. If you are using this page
            on a shared computer, you should clear any data that the browser
            has saved.</li>
            <li>You cannot view anyone else's private data by using this page.</li>
            <li>To clear your data, reload the page.</li>
            </ul>
        </fieldset>
    </form>


    <div>
		<h2>What's On This Page?</h2>
		<ul>
			<div id="sectionDesc"></div>
		</ul>
		<p><span class="subheading">FYI:</span> Last Active date is the latest date of either Cron, Chat, Drop and if fetching data for a party, either when a Buff or Transformational Item is cast. Activity is reflective of the Guild/Party only (Except for Last Cron/Last Drop). It does not include if the user is chatting, or using other areas within Habitica.</p>
		
		<h2>Possible Future Features</h2>
		<ul>
			<li>Better dialogue boxes particular with PMs (Yes they are ugly)</li>
			<li>Cards with PMs</li>
			<li>Chat Avatar</li>
			<li><span class="subheading">Other Stuff?</span>: Send me ideas! Contact details are below.</li>
		</ul>
		<p>Feel free to fork this and implement these features! (It's likely to be a long while before I get to them).</p>

		<h2>Known Bugs</h2>
		<p>The hiding and closing of sections is a bit funky. (One day I will fix it but not today.)</p>

		<p>Internet Explorer will produce odd results if you use the "Re-Fetch Data" button. Reloading the page will fix the problem. Avoid using that button. Avoiding Internet Explorer will also work.</p>
		<p>This page will not work correctly on old browsers because it uses modern website features and relies on compliance to standards (both can be lacking in old browsers). <a href="http://browsehappy.com/">Updating your browser is important for general safety on the Internet!</a> If you have upgraded your browser to the latest version and are still having problems, please tell me! Contact details are below.</p>
		<p>Regardless of what bugs there might be, this page cannot damage your account. It does not contain any code that could result in any changes being made on Habitica except actions performed through this tool via the API. The tool does not directly edit your data..</p>

		<h2>Thank You!</h2>
		<p>Thank you to @Alys & Ryan for their code which this is based. Thank you to Blade who provided me the code for the <a href="https://github.com/crookedneighbor/habitica-avatar">Avatars<a> both the js and implementation here. Thank you all in the <a href="https://habitica.com/groups/guild/349a36c3-66f3-4bf8-91b6-475056d9b6bb">Javascript</a> and <a href="https://habitica.com/groups/guild/2ff9822b-27f2-4774-98da-db349b57a38e">Aspiring Comrades</a> in answering my newbie questions. Shout out to Blade who help this newbie with her arrays as well as developing code to display the Avatars in the tool. Thank you to the Pirates (and conscripted socialites) who were keelhauled, walked the plank and thrown overboard in testing this product. Thank you to all the parties I joined that help me test this product; hopefully you dried out from all the snow.<p> 

		<h2>Help and Contact Details</h2>
		<p>This page has been created by <a href="http://habitica.wikia.com/wiki/User:CTheDragons">cTheDragons</a>. If you have questions, problems, or suggestions, you're welcome to contact me, although I cannot guarantee that I'll always be able to spend a lot of time on this. You can contact me at <a href="https://habitica.com/groups/guild/d9a0ec1e-352b-4697-a5d5-fb45c98fb4a3">Testing & Bug Squashing for Dragon Tools</a>. I tend to ignore emails & PMs.</p>
		<p>Code can be source at  <a href="https://github.com/cTheDragons/Habitica-Party-Guild-Data-Tool">Github<a>. Contributions are welcome. As already stated, any issues please report to  <a href="https://habitica.com/groups/guild/d9a0ec1e-352b-4697-a5d5-fb45c98fb4a3">Testing & Bug Squashing for Dragon Tools</a> for a faster response and to avoid duplication. </p>
		<p>If you have general questions about Habitica, post them to <a href="https://habitica.com/groups/tavern">Tavern</a> or <a href="https://habitica.com/groups/guild/5481ccf3-5d2d-48a9-a871-70a7380cee5a">Habitica Help: Ask a Question Guild</a>.</p>
    </div>
	
	<div id="documentationAndFormClose" class="showHideToggle closer" data-target="documentationAndForm" data-resettoggletext="documentationAndFormToggle">hide documentation / options</div>
	
</div><!-- end of div id="documentationAndForm" -->
	
</div><!-- end of div id="innerBody" -->
</body>
</html>
